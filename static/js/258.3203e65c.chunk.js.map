{"version":3,"file":"static/js/258.3203e65c.chunk.js","mappings":"8OAQO,MAqCMA,EAAiBC,UAC5B,IACEC,QAAQC,IAAI,iCACZD,QAAQC,IAAI,mBAAoBC,GAGhC,MAAMC,GAAWC,EAAAA,EAAAA,GAAA,GAAQF,GACzBF,QAAQC,IAAI,kBAAmBE,GAG/BE,OAAOC,KAAKH,GAAaI,SAAQC,IACN,KAArBL,EAAYK,IAAoC,OAArBL,EAAYK,WAClCL,EAAYK,MAKvB,IACER,QAAQC,IAAI,+CAEZ,MAAQQ,KAAMC,EAAUC,MAAOC,SAAoBC,EAAAA,EAChDC,KAAK,kBACLC,OAAO,aACPC,MAAM,GAEThB,QAAQC,IAAI,6BAA8B,CAAES,WAAUE,cAElDA,GAAgC,UAAnBA,EAAUK,OAEzBjB,QAAQkB,KAAK,qFACNf,EAAYgB,UAEvB,CAAE,MAAOC,GAEPpB,QAAQkB,KAAK,qFACNf,EAAYgB,SACrB,CAEAnB,QAAQC,IAAI,oCAA+BE,GAE3C,MAAM,KAAEM,EAAI,MAAEE,SAAgBE,EAAAA,EAC3BC,KAAK,kBACLO,OAAO,CAAClB,IACRY,SACAO,SAIH,GAFAtB,QAAQC,IAAI,wBAAyB,CAAEQ,OAAME,UAEzCA,EAEF,MADAX,QAAQW,MAAM,oBAAqBA,GAC7BA,EAIR,OADAX,QAAQC,IAAI,8BAA+BQ,GACpCA,CACT,CAAE,MAAOE,GAEP,MADAX,QAAQW,MAAM,qCAAsCA,GAC9CA,CACR,GASWY,EAAoBxB,MAAOyB,EAAIC,KAC1C,IACEzB,QAAQC,IAAI,oCACZD,QAAQC,IAAI,iBAAkBuB,GAC9BxB,QAAQC,IAAI,gCAA2BwB,GAGvC,MAAMC,GAAYtB,EAAAA,EAAAA,GAAA,GAAQqB,GAC1BpB,OAAOC,KAAKoB,GAAcnB,SAAQC,IACN,KAAtBkB,EAAalB,IAAqC,OAAtBkB,EAAalB,WACpCkB,EAAalB,MAIxBR,QAAQC,IAAI,uCAAkCyB,GAE9C,MAAM,KAAEjB,EAAI,MAAEE,SAAgBE,EAAAA,EAC3BC,KAAK,kBACLa,OAAOD,GACPE,GAAG,KAAMJ,GACTT,SACAO,SAIH,GAFAtB,QAAQC,IAAI,wBAAyB,CAAEQ,OAAME,UAEzCA,EAEF,MADAX,QAAQW,MAAM,iCAAkCA,GAC1CA,EAIR,OADAX,QAAQC,IAAI,kCAAmCQ,GACxCA,CACT,CAAE,MAAOE,GAEP,MADAX,QAAQW,MAAM,qCAAsCA,GAC9CA,CACR,GAmIWkB,EAAuB9B,eAAO+B,EAAWC,GAA+B,IAArBC,EAAQC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,KACzE,IACEjC,QAAQC,IAAI,oCAAqC,CAAE6B,YAAWC,WAAUC,aAGxE,IAAII,EAAQvB,EAAAA,EACTC,KAAK,kBACLC,OAAO,KACPa,GAAG,aAAcE,GACjBF,GAAG,YAAaG,GAChBH,GAAG,SAAS,GAEf,GAAII,EACF,IACEI,EAAQA,EAAMR,GAAG,YAAaI,EAChC,CAAE,MAAOZ,GACPpB,QAAQkB,KAAK,iEACf,CAGF,IAAI,KAAET,EAAI,MAAEE,SAAgByB,EAAMd,SAIlC,GAHAtB,QAAQC,IAAI,2BAA4B,CAAEQ,OAAME,UAG3CA,GAAwB,aAAfA,EAAMM,OAAyBR,EAAM,CACjDT,QAAQC,IAAI,2CAEZ,MAAMoC,EAAkBP,EAAUQ,MAAM,KAAKC,OAAO,GAAGC,KAAK,KAC5DxC,QAAQC,IAAI,gCAA8BoC,GAE1C,IAAII,EAAS5B,EAAAA,EACVC,KAAK,kBACLC,OAAO,KACP2B,MAAM,aAAa,KAADC,OAAON,IACzBT,GAAG,YAAaG,GAChBH,GAAG,SAAS,GAEf,GAAII,EACF,IACES,EAASA,EAAOb,GAAG,YAAaI,EAClC,CAAE,MAAOZ,GACP,CAIJ,MAAQX,KAAMmC,EAAOjC,MAAOkC,SAAiBJ,EAAOnB,SAGpD,GAFAtB,QAAQC,IAAI,2CAAsC,CAAE2C,QAAOC,YAEtDA,GAAUD,EACb,OAAOA,CAEX,CAEA,GAAIjC,GAAwB,aAAfA,EAAMM,KACjB,MAAMN,EAGR,OAAOF,GAAQ,IACjB,CAAE,MAAOE,GAEP,OADAX,QAAQW,MAAM,kCAAmCA,GAC1C,IACT,CACF,EAQamC,EAAsB/C,MAAOgD,EAAUhB,KAClD,IACE,MAAM,KAAEtB,EAAI,MAAEE,SAAgBE,EAAAA,EAC3BC,KAAK,kBACLC,OAAO,KACPa,GAAG,YAAamB,GAChBnB,GAAG,YAAaG,GAChBH,GAAG,SAAS,GACZN,SAEH,GAAIX,GAAwB,aAAfA,EAAMM,KACjB,MAAMN,EAGR,OAAOF,GAAQ,IACjB,CAAE,MAAOE,GAEP,OADAX,QAAQW,MAAM,oCAAkCA,GACzC,IACT,GAsHWqC,EAAoBjD,UAC/B,IACEC,QAAQC,IAAI,iEAGZ,MAAQQ,KAAMwC,EAAWtC,MAAOuC,SAAqBrC,EAAAA,EAClDC,KAAK,kBACLC,OAAO,KACPC,MAAM,GAIT,GAFAhB,QAAQC,IAAI,2BAA4B,CAAEgD,YAAWC,eAEjDA,EAEF,YADAlD,QAAQW,MAAM,mFAAmEuC,GAKnF,MAAQzC,KAAM0C,EAAexC,MAAOyC,SAAyBvC,EAAAA,EAC1DC,KAAK,kBACLC,OAAO,4HACPC,MAAM,GAEThB,QAAQC,IAAI,iCAAkC,CAAEkD,gBAAeC,mBAE3DA,EACFpD,QAAQW,MAAM,iDAA6CyC,GAE3DpD,QAAQC,IAAI,mDAId,IACE,MAAQQ,KAAM4C,EAAU1C,MAAO2C,SAAoBzC,EAAAA,EAChDC,KAAK,kBACLC,OAAO,aACPC,MAAM,GAEThB,QAAQC,IAAI,8BAA+B,CAAEoD,WAAUC,cAEnDA,GAAgC,UAAnBA,EAAUrC,KACzBjB,QAAQC,IAAI,gEACHqD,EACTtD,QAAQW,MAAM,8CAA0C2C,GAExDtD,QAAQC,IAAI,iCAEhB,CAAE,MAAOqD,GACPtD,QAAQC,IAAI,+DACd,CAGAD,QAAQC,IAAI,wCACZ,MAAMsD,EAAa,CACjBC,UAAW,OACXC,WAAY,gBACZvD,QAAS,mBACTwD,oBAAqB,2BACrBC,WAAY,QACZC,UAAW,aACXC,UAAW,QACXC,OAAO,EACPC,YAAY,IAAIC,MAAOC,cACvBC,YAAY,IAAIF,MAAOC,eAGzB,IACE,MAAQxD,KAAM0D,EAAYxD,MAAOyD,SAAsBvD,EAAAA,EACpDC,KAAK,kBACLO,OAAO,CAACkC,IACRxC,SACAO,SAIH,GAFAtB,QAAQC,IAAI,qCAAgC,CAAEkE,aAAYC,gBAEtDA,EACFpE,QAAQW,MAAM,4CAAkCyD,OAC3C,CACLpE,QAAQC,IAAI,sEAGZ,MAAQU,MAAO0D,SAAsBxD,EAAAA,EAClCC,KAAK,kBACLwD,SACA1C,GAAG,KAAMuC,EAAW3C,IAEnB6C,EACFrE,QAAQW,MAAM,wEAAyD0D,GAEvErE,QAAQC,IAAI,gDAEhB,CACF,CAAE,MAAOmE,GACPpE,QAAQW,MAAM,iDAAuCyD,EACvD,CAEApE,QAAQC,IAAI,uBAEd,CAAE,MAAOU,GACPX,QAAQW,MAAM,wCAAoCA,EACpD,E,sFCrkBF,MAAM4D,EAA4B,CAChCC,YAAa,6BACbC,cAAe,QACfC,cAAe,CAAC,aAAc,YAAa,YAAa,aAAc,aACtEC,wBAAyB,EACzBC,eAAgB,CAAEC,MAAO,IAAKC,OAAQ,MA2E3BC,EAAwBhF,UACnC,IACE,MAAM,KAAEU,EAAI,MAAEE,SAAgBE,EAAAA,EAC3BC,KAAK,uBACLC,OAAO,KACPa,GAAG,YAAaG,GAChBH,GAAG,SAAS,GACZoD,MAAM,QAAS,CAAEC,WAAW,IAC5BD,MAAM,aAAc,CAAEC,WAAW,IAEpC,GAAItE,EACF,MAAMA,EAGR,IAAKF,GAAwB,IAAhBA,EAAKyB,OAChB,MAAO,GAmBT,OAf4BzB,EAAKyE,KAAKC,IACpC,GAAIA,EAAS1B,WACX,IACE,MAAQhD,MAAM,UAAE2E,IAAgBvE,EAAAA,EAASwE,QACtCvE,KAAKyD,EAA0BC,aAC/Bc,aAAaH,EAAS1B,YAEzB,OAAArD,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GAAY+E,GAAQ,IAAEI,kBAAmBH,GAC3C,CAAE,MAAOI,GACP,OAAApF,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GAAY+E,GAAQ,IAAEI,kBAAmB,KAAME,SAAUD,EAAIE,SAC/D,CAEF,OAAOP,IAKX,CAAE,MAAOxE,GAEP,MADAX,QAAQW,MAAM,4CAA0CA,GAClDA,CACR,GAQWgF,EAA0B5F,UACrC,IACE,MAAM,KAAEU,EAAI,MAAEE,SAAgBE,EAAAA,EAC3BC,KAAK,uBACLO,OAAO,CAAC,CACPmC,UAAWoC,EAAapC,UACxBqC,eAAgBD,EAAaC,gBAAkB,KAC/CV,SAAUS,EAAaT,SACvBW,MAAOF,EAAaE,OAAS,EAC7BhC,OAA8B,IAAvB8B,EAAa9B,SAErB/C,SACAO,SAEH,GAAIX,EACF,MAAMA,EAGR,OAAOF,CAET,CAAE,MAAOE,GAEP,MADAX,QAAQW,MAAM,0CAAwCA,GAChDA,CACR,GASWoF,EAA0BhG,MAAOiG,EAAYJ,KACxD,IACE,MAAM,KAAEnF,EAAI,MAAEE,SAAgBE,EAAAA,EAC3BC,KAAK,uBACLa,OAAO,CACNkE,eAAgBD,EAAaC,eAC7BV,SAAUS,EAAaT,SACvBW,MAAOF,EAAaE,MACpBhC,MAAO8B,EAAa9B,MACpBI,YAAY,IAAIF,MAAOC,gBAExBrC,GAAG,KAAMoE,GACTjF,SACAO,SAEH,GAAIX,EACF,MAAMA,EAGR,OAAOF,CAET,CAAE,MAAOE,GAEP,MADAX,QAAQW,MAAM,8CAA4CA,GACpDA,CACR,GAQWsF,EAA0BlG,UACrC,IAEE,MAAQY,MAAO0D,SAAsBxD,EAAAA,EAClCC,KAAK,uBACLwD,SACA1C,GAAG,KAAMoE,GAEZ,GAAI3B,EACF,MAAMA,CAEV,CAAE,MAAO1D,GAEP,MADAX,QAAQW,MAAM,4CAA0CA,GAClDA,CACR,E","sources":["services/legendasService.js","services/historiaProfessorService.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\n\n/**\n * Buscar legendas de fotos de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor' (opcional, busca todas se não especificado)\n * @returns {Promise<Array>} Lista de legendas de fotos\n */\nexport const getLegendasFotos = async (escolaId, tipoFoto = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    // Verificar se a coluna tipo_foto existe antes de usá-la\n    if (tipoFoto) {\n      try {\n        query = query.eq('tipo_foto', tipoFoto);\n      } catch (columnError) {\n        // Se a coluna não existe, ignorar o filtro por tipo\n        console.warn('Coluna tipo_foto não encontrada. Ignorando filtro por tipo.');\n      }\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas de fotos:', error);\n    throw error;\n  }\n};\n\n/**\n * Adicionar legenda de foto\n * @param {Object} legenda - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legenda) => {\n  try {\n    console.log('=== DEBUG: addLegendaFoto ===');\n    console.log('Dados recebidos:', legenda);\n    \n    // Remover tipo_foto se a coluna não existir no banco\n    const legendaData = { ...legenda };\n    console.log('Dados iniciais:', legendaData);\n    \n    // Limpar campos vazios que podem causar problemas com o banco\n    Object.keys(legendaData).forEach(key => {\n      if (legendaData[key] === '' || legendaData[key] === null) {\n        delete legendaData[key];\n      }\n    });\n    \n    // Verificar se a coluna tipo_foto existe antes de incluí-la\n    try {\n      console.log('Verificando se a coluna tipo_foto existe...');\n      // Tentar uma consulta simples para verificar se a coluna existe\n      const { data: testData, error: testError } = await supabase\n        .from('legendas_fotos')\n        .select('tipo_foto')\n        .limit(1);\n      \n      console.log('Teste da coluna tipo_foto:', { testData, testError });\n      \n      if (testError && testError.code === '42703') {\n        // Se a coluna não existe, remover do objeto\n        console.warn('Coluna tipo_foto não encontrada. Removendo do objeto de inserção.');\n        delete legendaData.tipo_foto;\n      }\n    } catch (columnError) {\n      // Se a coluna não existe, remover do objeto\n      console.warn('Coluna tipo_foto não encontrada. Removendo do objeto de inserção.');\n      delete legendaData.tipo_foto;\n    }\n\n    console.log('Dados finais para inserção:', legendaData);\n    \n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    console.log('Resposta do Supabase:', { data, error });\n\n    if (error) {\n      console.error('Erro do Supabase:', error);\n      throw error;\n    }\n\n    console.log('Legenda criada com sucesso:', data);\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto\n * @param {number} id - ID da legenda\n * @param {Object} updates - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (id, updates) => {\n  try {\n    console.log('=== DEBUG: updateLegendaFoto ===');\n    console.log('ID da legenda:', id);\n    console.log('Dados para atualização:', updates);\n    \n    // Limpar campos vazios que podem causar problemas com o banco\n    const cleanUpdates = { ...updates };\n    Object.keys(cleanUpdates).forEach(key => {\n      if (cleanUpdates[key] === '' || cleanUpdates[key] === null) {\n        delete cleanUpdates[key];\n      }\n    });\n    \n    console.log('Dados limpos para atualização:', cleanUpdates);\n    \n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(cleanUpdates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    console.log('Resposta do Supabase:', { data, error });\n\n    if (error) {\n      console.error('Erro do Supabase ao atualizar:', error);\n      throw error;\n    }\n\n    console.log('Legenda atualizada com sucesso:', data);\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto (soft delete)\n * @param {number} id - ID da legenda\n * @returns {Promise<boolean>} Sucesso da operação\n */\nexport const deleteLegendaFoto = async (id) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .update({ ativo: false })\n      .eq('id', id);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar títulos de vídeos de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de títulos de vídeos\n */\nexport const getTitulosVideos = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar títulos de vídeos:', error);\n    throw error;\n  }\n};\n\n/**\n * Adicionar título de vídeo\n * @param {Object} titulo - Dados do título\n * @returns {Promise<Object>} Título criado\n */\nexport const addTituloVideo = async (titulo) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .insert([titulo])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar título de vídeo\n * @param {number} id - ID do título\n * @param {Object} updates - Dados para atualizar\n * @returns {Promise<Object>} Título atualizado\n */\nexport const updateTituloVideo = async (id, updates) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar título de vídeo (soft delete)\n * @param {number} id - ID do título\n * @returns {Promise<boolean>} Sucesso da operação\n */\nexport const deleteTituloVideo = async (id) => {\n  try {\n    const { error } = await supabase\n      .from('titulos_videos')\n      .update({ ativo: false })\n      .eq('id', id);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar legenda de foto por URL da imagem\n * @param {string} imagemUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor' (opcional)\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imagemUrl, escolaId, tipoFoto = null) => {\n  try {\n    console.log('getLegendaByImageUrl chamada com:', { imagemUrl, escolaId, tipoFoto });\n    \n    // 1. Tenta buscar por igualdade exata\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imagemUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (tipoFoto) {\n      try {\n        query = query.eq('tipo_foto', tipoFoto);\n      } catch (columnError) {\n        console.warn('Coluna tipo_foto não encontrada. Ignorando filtro por tipo.');\n      }\n    }\n\n    let { data, error } = await query.single();\n    console.log('Busca exata resultou em:', { data, error });\n\n    // Se não encontrou, tenta buscar por finalização\n    if ((error && error.code === 'PGRST116') || !data) {\n      console.log('Tentando busca por finalização...');\n      // Busca por finalização (ilike)\n      const caminhoRelativo = imagemUrl.split('/').slice(-2).join('/'); // ex: 20/2.png\n      console.log('Caminho relativo extraído:', caminhoRelativo);\n      \n      let query2 = supabase\n        .from('legendas_fotos')\n        .select('*')\n        .ilike('imagem_url', `%/${caminhoRelativo}`)\n        .eq('escola_id', escolaId)\n        .eq('ativo', true);\n\n      if (tipoFoto) {\n        try {\n          query2 = query2.eq('tipo_foto', tipoFoto);\n        } catch (columnError) {\n          // Se a coluna não existe, ignora\n        }\n      }\n\n      const { data: data2, error: error2 } = await query2.single();\n      console.log('Busca por finalização resultou em:', { data2, error2 });\n      \n      if (!error2 && data2) {\n        return data2;\n      }\n    }\n\n    if (error && error.code !== 'PGRST116') {\n      throw error;\n    }\n\n    return data || null;\n  } catch (error) {\n    console.error('Erro ao buscar legenda por URL:', error);\n    return null;\n  }\n};\n\n/**\n * Buscar título de vídeo por URL do vídeo\n * @param {string} videoUrl - URL do vídeo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Título encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .select('*')\n      .eq('video_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .single();\n\n    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned\n      throw error;\n    }\n\n    return data || null;\n  } catch (error) {\n    console.error('Erro ao buscar título por URL:', error);\n    return null;\n  }\n};\n\n/**\n * Migrar dados existentes de imagens para legendas\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor'\n * @returns {Promise<Array>} Legendas migradas\n */\nexport const migrarLegendasExistentes = async (escolaId, tipoFoto = 'escola') => {\n  try {\n    let imagens = [];\n    \n    if (tipoFoto === 'escola') {\n      // Buscar imagens existentes da tabela imagens_escola\n      const { data, error } = await supabase\n        .from('imagens_escola')\n        .select('*')\n        .eq('escola_id', escolaId)\n        .eq('ativo', true);\n\n      if (error) {\n        throw error;\n      }\n      imagens = data || [];\n    } else if (tipoFoto === 'professor') {\n      // Buscar imagens dos professores do bucket\n      const { data, error } = await supabase.storage\n        .from('imagens-professores')\n        .list(`${escolaId}/`);\n\n      if (error) {\n        throw error;\n      }\n      \n      imagens = (data || []).map(file => ({\n        url: `${escolaId}/${file.name}`,\n        descricao: `Imagem do professor - ${file.name}`,\n        created_at: file.created_at\n      }));\n    }\n\n    const legendasMigradas = [];\n\n    for (const imagem of imagens) {\n      // Verificar se já existe legenda para esta imagem\n      const legendaExistente = await getLegendaByImageUrl(imagem.url, escolaId, tipoFoto);\n      \n      if (!legendaExistente) {\n        // Criar nova legenda\n        const novaLegenda = await addLegendaFoto({\n          escola_id: escolaId,\n          imagem_url: imagem.url,\n          legenda: imagem.descricao || `Imagem da ${tipoFoto}`,\n          descricao_detalhada: imagem.descricao,\n          categoria: 'geral',\n          tipo_foto: tipoFoto,\n          ativo: true\n        });\n        \n        legendasMigradas.push(novaLegenda);\n      }\n    }\n\n    return legendasMigradas;\n  } catch (error) {\n    console.error('Erro ao migrar legendas existentes:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes de vídeos para títulos\n * @param {number} escolaId - ID da escola\n * @param {string} videoUrl - URL do vídeo\n * @returns {Promise<Object|null>} Título migrado\n */\nexport const migrarTituloExistente = async (escolaId, videoUrl) => {\n  try {\n    if (!videoUrl) return null;\n\n    // Verificar se já existe título para este vídeo\n    const tituloExistente = await getTituloByVideoUrl(videoUrl, escolaId);\n    \n    if (!tituloExistente) {\n      // Determinar plataforma\n      let plataforma = 'outro';\n      if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {\n        plataforma = 'youtube';\n      } else if (videoUrl.includes('vimeo.com')) {\n        plataforma = 'vimeo';\n      }\n\n      // Criar novo título\n      const novoTitulo = await addTituloVideo({\n        escola_id: escolaId,\n        video_url: videoUrl,\n        titulo: `Vídeo da Escola - ${plataforma.charAt(0).toUpperCase() + plataforma.slice(1)}`,\n        descricao: 'Vídeo relacionado à escola indígena',\n        plataforma: plataforma,\n        categoria: 'geral',\n        ativo: true\n      });\n      \n      return novoTitulo;\n    }\n\n    return tituloExistente;\n  } catch (error) {\n    console.error('Erro ao migrar título existente:', error);\n    throw error;\n  }\n};\n\n/**\n * Função de teste para verificar a estrutura da tabela legendas_fotos\n * @returns {Promise<void>}\n */\nexport const testLegendasTable = async () => {\n  try {\n    console.log('=== TESTE: Verificando estrutura da tabela legendas_fotos ===');\n    \n    // Teste 1: Verificar se a tabela existe\n    const { data: tableData, error: tableError } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .limit(1);\n    \n    console.log('Teste 1 - Tabela existe:', { tableData, tableError });\n    \n    if (tableError) {\n      console.error('❌ ERRO: Tabela legendas_fotos não existe ou não está acessível:', tableError);\n      return;\n    }\n    \n    // Teste 2: Verificar estrutura da tabela\n    const { data: structureData, error: structureError } = await supabase\n      .from('legendas_fotos')\n      .select('id, escola_id, imagem_url, legenda, descricao_detalhada, autor_foto, data_foto, categoria, ativo, created_at, updated_at')\n      .limit(1);\n    \n    console.log('Teste 2 - Estrutura da tabela:', { structureData, structureError });\n    \n    if (structureError) {\n      console.error('❌ ERRO: Problema com estrutura da tabela:', structureError);\n    } else {\n      console.log('✅ Estrutura básica da tabela está OK');\n    }\n    \n    // Teste 3: Verificar se a coluna tipo_foto existe\n    try {\n      const { data: tipoData, error: tipoError } = await supabase\n        .from('legendas_fotos')\n        .select('tipo_foto')\n        .limit(1);\n      \n      console.log('Teste 3 - Coluna tipo_foto:', { tipoData, tipoError });\n      \n      if (tipoError && tipoError.code === '42703') {\n        console.log('⚠️ AVISO: Coluna tipo_foto não existe na tabela');\n      } else if (tipoError) {\n        console.error('❌ ERRO: Problema com coluna tipo_foto:', tipoError);\n      } else {\n        console.log('✅ Coluna tipo_foto existe');\n      }\n    } catch (tipoError) {\n      console.log('⚠️ AVISO: Coluna tipo_foto não existe na tabela');\n    }\n    \n    // Teste 4: Tentar inserir um registro de teste\n    console.log('Teste 4 - Testando inserção...');\n    const testRecord = {\n      escola_id: 999999, // ID que não existe\n      imagem_url: 'test/test.jpg',\n      legenda: 'Teste de legenda',\n      descricao_detalhada: 'Descrição de teste',\n      autor_foto: 'Teste',\n      data_foto: '2024-01-01',\n      categoria: 'teste',\n      ativo: true,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n    \n    try {\n      const { data: insertData, error: insertError } = await supabase\n        .from('legendas_fotos')\n        .insert([testRecord])\n        .select()\n        .single();\n      \n      console.log('Teste 4 - Inserção de teste:', { insertData, insertError });\n      \n      if (insertError) {\n        console.error('❌ ERRO: Problema com inserção:', insertError);\n      } else {\n        console.log('✅ Inserção funcionando - removendo registro de teste...');\n        \n        // Remover o registro de teste\n        const { error: deleteError } = await supabase\n          .from('legendas_fotos')\n          .delete()\n          .eq('id', insertData.id);\n        \n        if (deleteError) {\n          console.error('⚠️ AVISO: Não foi possível remover registro de teste:', deleteError);\n        } else {\n          console.log('✅ Registro de teste removido com sucesso');\n        }\n      }\n    } catch (insertError) {\n      console.error('❌ ERRO: Falha na inserção de teste:', insertError);\n    }\n    \n    console.log('=== FIM DO TESTE ===');\n    \n  } catch (error) {\n    console.error('❌ ERRO GERAL no teste da tabela:', error);\n  }\n}; \n ","import { supabase } from '../supabaseClient';\n\n// Configurações para imagens das histórias do professor\nconst HISTORIA_PROFESSOR_CONFIG = {\n  BUCKET_NAME: 'historia-professor-imagens',\n  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB\n  ALLOWED_TYPES: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'],\n  MAX_IMAGES_PER_HISTORIA: 1,\n  MIN_DIMENSIONS: { width: 200, height: 200 }\n};\n\n/**\n * Valida um arquivo de imagem\n * @param {File} file - Arquivo a ser validado\n * @returns {Object} Resultado da validação\n */\nconst validateImageFile = (file) => {\n  // Verificar tipo MIME\n  if (!HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.includes(file.type)) {\n    return {\n      isValid: false,\n      error: `Tipo de arquivo não suportado. Use apenas: ${HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1].toUpperCase()).join(', ')}`\n    };\n  }\n\n  // Verificar tamanho\n  if (file.size > HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE) {\n    return {\n      isValid: false,\n      error: `Arquivo muito grande. Tamanho máximo: ${HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB`\n    };\n  }\n\n  // Verificar extensão\n  const extension = file.name.split('.').pop().toLowerCase();\n  const allowedExtensions = HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1]);\n  if (!allowedExtensions.includes(extension)) {\n    return {\n      isValid: false,\n      error: `Extensão não permitida. Use apenas: ${allowedExtensions.join(', ')}`\n    };\n  }\n\n  return { isValid: true };\n};\n\n/**\n * Valida dimensões da imagem (opcional)\n * @param {File} file - Arquivo de imagem\n * @returns {Promise<boolean>} Se as dimensões são válidas\n */\nconst validateImageDimensions = (file) => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      const isValid = img.width >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.width &&\n                     img.height >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.height;\n      resolve(isValid);\n    };\n    img.onerror = () => resolve(false);\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Gera nome único para o arquivo\n * @param {File} file - Arquivo\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da história\n * @returns {string} Nome único do arquivo\n */\nconst generateUniqueFileName = (file, escolaId, historiaId) => {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  const extension = file.name.split('.').pop().toLowerCase();\n  return `historia_${historiaId}_${timestamp}_${random}.${extension}`;\n};\n\n/**\n * Buscar todas as histórias do professor de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de histórias\n */\nexport const getHistoriasProfessor = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Adicionar URLs públicas das imagens\n    const historiasComImagens = data.map((historia) => {\n      if (historia.imagem_url) {\n        try {\n          const { data: { publicUrl } } = supabase.storage\n            .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n            .getPublicUrl(historia.imagem_url);\n\n          return { ...historia, imagem_public_url: publicUrl };\n        } catch (err) {\n          return { ...historia, imagem_public_url: null, urlError: err.message };\n        }\n      }\n      return historia;\n    });\n\n    return historiasComImagens;\n\n  } catch (error) {\n    console.error('Erro ao buscar histórias do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Criar nova história do professor\n * @param {Object} historiaData - Dados da história\n * @returns {Promise<Object>} História criada\n */\nexport const createHistoriaProfessor = async (historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .insert([{\n        escola_id: historiaData.escola_id,\n        nome_professor: historiaData.nome_professor || null,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem || 1,\n        ativo: historiaData.ativo !== false\n      }])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    console.error('Erro ao criar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar história do professor\n * @param {number} historiaId - ID da história\n * @param {Object} historiaData - Dados atualizados\n * @returns {Promise<Object>} História atualizada\n */\nexport const updateHistoriaProfessor = async (historiaId, historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .update({\n        nome_professor: historiaData.nome_professor,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem,\n        ativo: historiaData.ativo,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    console.error('Erro ao atualizar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar história do professor\n * @param {number} historiaId - ID da história\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessor = async (historiaId) => {\n  try {\n    // Deletar a história\n    const { error: deleteError } = await supabase\n      .from('historias_professor')\n      .delete()\n      .eq('id', historiaId);\n\n    if (deleteError) {\n      throw deleteError;\n    }\n  } catch (error) {\n    console.error('Erro ao deletar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Upload de imagem para uma história do professor\n * @param {File} file - Arquivo de imagem\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da história\n * @param {string} descricao - Descrição da imagem\n * @returns {Promise<Object>} Dados da imagem salva\n */\nexport const uploadHistoriaProfessorImage = async (file, escolaId, historiaId, descricao = '') => {\n  try {\n    // Validar arquivo\n    const validation = validateImageFile(file);\n    if (!validation.isValid) {\n      throw new Error(validation.error);\n    }\n\n    // Validar dimensões (opcional)\n    const hasValidDimensions = await validateImageDimensions(file);\n    if (!hasValidDimensions) {\n      console.warn('Imagem com dimensões menores que o recomendado');\n    }\n\n    // Gerar nome único\n    const fileName = generateUniqueFileName(file, escolaId, historiaId);\n    const filePath = `${escolaId}/${fileName}`;\n\n    // Upload ao bucket\n    const { error: uploadError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false\n      });\n\n    if (uploadError) {\n      throw new Error(`Erro no upload: ${uploadError.message}`);\n    }\n\n    // Obter URL pública\n    const { data: { publicUrl } } = supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .getPublicUrl(filePath);\n\n    // Atualizar a história com a URL da imagem\n    const { data: historia, error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: descricao.trim() || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (updateError) {\n      // Se falhar ao atualizar, deletar o arquivo\n      await supabase.storage\n        .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n        .remove([filePath]);\n      throw new Error(`Erro ao salvar metadados: ${updateError.message}`);\n    }\n\n    return {\n      id: historia.id,\n      descricao_imagem: historia.descricao_imagem\n    };\n\n  } catch (error) {\n    console.error('Erro no upload da imagem da história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar imagem de uma história do professor\n * @param {number} historiaId - ID da história\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessorImage = async (historiaId) => {\n  try {\n    // Buscar a história para obter a URL da imagem\n    const { data: historia, error: fetchError } = await supabase\n      .from('historias_professor')\n      .select('imagem_url')\n      .eq('id', historiaId)\n      .single();\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!historia.imagem_url) {\n      return; // Não há imagem para deletar\n    }\n\n    // Atualizar a história removendo a referência da imagem\n    const { error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId);\n\n    if (updateError) {\n      throw updateError;\n    }\n\n    // Deletar arquivo do storage\n    const { error: storageError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .remove([historia.imagem_url]);\n\n    if (storageError) {\n      console.warn('Erro ao deletar imagem do storage:', storageError);\n    }\n\n  } catch (error) {\n    console.error('Erro ao deletar imagem da história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes da tabela escolas_completa\n * @returns {Promise<Object>} Resultado da migração\n */\nexport const migrarDadosExistentes = async () => {\n  try {\n    // Buscar escolas com história do professor\n    const { data: escolas, error: fetchError } = await supabase\n      .from('escolas_completa')\n      .select('id, historia_do_prof')\n      .not('historia_do_prof', 'is', null)\n      .neq('historia_do_prof', '');\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!escolas || escolas.length === 0) {\n      return { migradas: 0, mensagem: 'Nenhuma história para migrar' };\n    }\n\n    // Inserir histórias na nova tabela\n    const historiasParaInserir = escolas.map(escola => ({\n      escola_id: escola.id,\n      historia: escola.historia_do_prof,\n      ordem: 1,\n      ativo: true,\n      created_at: new Date().toISOString()\n    }));\n\n    const { data: historiasInseridas, error: insertError } = await supabase\n      .from('historias_professor')\n      .insert(historiasParaInserir)\n      .select();\n\n    if (insertError) {\n      throw insertError;\n    }\n\n    return {\n      migradas: historiasInseridas.length,\n      mensagem: `${historiasInseridas.length} histórias migradas com sucesso`\n    };\n\n  } catch (error) {\n    console.error('Erro na migração de dados:', error);\n    throw error;\n  }\n};\n\n/**\n * Verificar se uma escola tem histórias do professor\n * @param {number} escolaId - ID da escola\n * @returns {Promise<boolean>} Se tem histórias\n */\nexport const escolaTemHistoriasProfessor = async (escolaId) => {\n  try {\n    const { count, error } = await supabase\n      .from('historias_professor')\n      .select('*', { count: 'exact', head: true })\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (error) {\n      throw error;\n    }\n\n    return (count || 0) > 0;\n\n  } catch (error) {\n    console.error('Erro ao verificar histórias do professor:', error);\n    return false;\n  }\n}; "],"names":["addLegendaFoto","async","console","log","legenda","legendaData","_objectSpread","Object","keys","forEach","key","data","testData","error","testError","supabase","from","select","limit","code","warn","tipo_foto","columnError","insert","single","updateLegendaFoto","id","updates","cleanUpdates","update","eq","getLegendaByImageUrl","imagemUrl","escolaId","tipoFoto","arguments","length","undefined","query","caminhoRelativo","split","slice","join","query2","ilike","concat","data2","error2","getTituloByVideoUrl","videoUrl","testLegendasTable","tableData","tableError","structureData","structureError","tipoData","tipoError","testRecord","escola_id","imagem_url","descricao_detalhada","autor_foto","data_foto","categoria","ativo","created_at","Date","toISOString","updated_at","insertData","insertError","deleteError","delete","HISTORIA_PROFESSOR_CONFIG","BUCKET_NAME","MAX_FILE_SIZE","ALLOWED_TYPES","MAX_IMAGES_PER_HISTORIA","MIN_DIMENSIONS","width","height","getHistoriasProfessor","order","ascending","map","historia","publicUrl","storage","getPublicUrl","imagem_public_url","err","urlError","message","createHistoriaProfessor","historiaData","nome_professor","ordem","updateHistoriaProfessor","historiaId","deleteHistoriaProfessor"],"sourceRoot":""}