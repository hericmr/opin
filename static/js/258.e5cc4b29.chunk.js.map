{"version":3,"file":"static/js/258.e5cc4b29.chunk.js","mappings":"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","sources":["services/legendasService.js","services/historiaProfessorService.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\n\n/**\n * Buscar legendas de fotos de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor' (opcional, busca todas se não especificado)\n * @returns {Promise<Array>} Lista de legendas de fotos\n */\nexport const getLegendasFotos = async (escolaId, tipoFoto = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    // Verificar se a coluna tipo_foto existe antes de usá-la\n    if (tipoFoto) {\n      try {\n        query = query.eq('tipo_foto', tipoFoto);\n      } catch (columnError) {\n        // Se a coluna não existe, ignorar o filtro por tipo\n        console.warn('Coluna tipo_foto não encontrada. Ignorando filtro por tipo.');\n      }\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas de fotos:', error);\n    throw error;\n  }\n};\n\n/**\n * Adicionar legenda de foto\n * @param {Object} legenda - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legenda) => {\n  try {\n    console.log('=== DEBUG: addLegendaFoto ===');\n    console.log('Dados recebidos:', legenda);\n    \n    // Remover tipo_foto se a coluna não existir no banco\n    const legendaData = { ...legenda };\n    console.log('Dados iniciais:', legendaData);\n    \n    // Verificar se a coluna tipo_foto existe antes de incluí-la\n    try {\n      console.log('Verificando se a coluna tipo_foto existe...');\n      // Tentar uma consulta simples para verificar se a coluna existe\n      const { data: testData, error: testError } = await supabase\n        .from('legendas_fotos')\n        .select('tipo_foto')\n        .limit(1);\n      \n      console.log('Teste da coluna tipo_foto:', { testData, testError });\n      \n      if (testError && testError.code === '42703') {\n        // Se a coluna não existe, remover do objeto\n        console.warn('Coluna tipo_foto não encontrada. Removendo do objeto de inserção.');\n        delete legendaData.tipo_foto;\n      }\n    } catch (columnError) {\n      // Se a coluna não existe, remover do objeto\n      console.warn('Coluna tipo_foto não encontrada. Removendo do objeto de inserção.');\n      delete legendaData.tipo_foto;\n    }\n\n    console.log('Dados finais para inserção:', legendaData);\n    \n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    console.log('Resposta do Supabase:', { data, error });\n\n    if (error) {\n      console.error('Erro do Supabase:', error);\n      throw error;\n    }\n\n    console.log('Legenda criada com sucesso:', data);\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto\n * @param {number} id - ID da legenda\n * @param {Object} updates - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (id, updates) => {\n  try {\n    console.log('=== DEBUG: updateLegendaFoto ===');\n    console.log('ID da legenda:', id);\n    console.log('Dados para atualização:', updates);\n    \n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    console.log('Resposta do Supabase:', { data, error });\n\n    if (error) {\n      console.error('Erro do Supabase ao atualizar:', error);\n      throw error;\n    }\n\n    console.log('Legenda atualizada com sucesso:', data);\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto (soft delete)\n * @param {number} id - ID da legenda\n * @returns {Promise<boolean>} Sucesso da operação\n */\nexport const deleteLegendaFoto = async (id) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .update({ ativo: false })\n      .eq('id', id);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar títulos de vídeos de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de títulos de vídeos\n */\nexport const getTitulosVideos = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar títulos de vídeos:', error);\n    throw error;\n  }\n};\n\n/**\n * Adicionar título de vídeo\n * @param {Object} titulo - Dados do título\n * @returns {Promise<Object>} Título criado\n */\nexport const addTituloVideo = async (titulo) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .insert([titulo])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar título de vídeo\n * @param {number} id - ID do título\n * @param {Object} updates - Dados para atualizar\n * @returns {Promise<Object>} Título atualizado\n */\nexport const updateTituloVideo = async (id, updates) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar título de vídeo (soft delete)\n * @param {number} id - ID do título\n * @returns {Promise<boolean>} Sucesso da operação\n */\nexport const deleteTituloVideo = async (id) => {\n  try {\n    const { error } = await supabase\n      .from('titulos_videos')\n      .update({ ativo: false })\n      .eq('id', id);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar legenda de foto por URL da imagem\n * @param {string} imagemUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor' (opcional)\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imagemUrl, escolaId, tipoFoto = null) => {\n  try {\n    console.log('getLegendaByImageUrl chamada com:', { imagemUrl, escolaId, tipoFoto });\n    \n    // 1. Tenta buscar por igualdade exata\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imagemUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (tipoFoto) {\n      try {\n        query = query.eq('tipo_foto', tipoFoto);\n      } catch (columnError) {\n        console.warn('Coluna tipo_foto não encontrada. Ignorando filtro por tipo.');\n      }\n    }\n\n    let { data, error } = await query.single();\n    console.log('Busca exata resultou em:', { data, error });\n\n    // Se não encontrou, tenta buscar por finalização\n    if ((error && error.code === 'PGRST116') || !data) {\n      console.log('Tentando busca por finalização...');\n      // Busca por finalização (ilike)\n      const caminhoRelativo = imagemUrl.split('/').slice(-2).join('/'); // ex: 20/2.png\n      console.log('Caminho relativo extraído:', caminhoRelativo);\n      \n      let query2 = supabase\n        .from('legendas_fotos')\n        .select('*')\n        .ilike('imagem_url', `%/${caminhoRelativo}`)\n        .eq('escola_id', escolaId)\n        .eq('ativo', true);\n\n      if (tipoFoto) {\n        try {\n          query2 = query2.eq('tipo_foto', tipoFoto);\n        } catch (columnError) {\n          // Se a coluna não existe, ignora\n        }\n      }\n\n      const { data: data2, error: error2 } = await query2.single();\n      console.log('Busca por finalização resultou em:', { data2, error2 });\n      \n      if (!error2 && data2) {\n        return data2;\n      }\n    }\n\n    if (error && error.code !== 'PGRST116') {\n      throw error;\n    }\n\n    return data || null;\n  } catch (error) {\n    console.error('Erro ao buscar legenda por URL:', error);\n    return null;\n  }\n};\n\n/**\n * Buscar título de vídeo por URL do vídeo\n * @param {string} videoUrl - URL do vídeo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Título encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .select('*')\n      .eq('video_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .single();\n\n    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned\n      throw error;\n    }\n\n    return data || null;\n  } catch (error) {\n    console.error('Erro ao buscar título por URL:', error);\n    return null;\n  }\n};\n\n/**\n * Migrar dados existentes de imagens para legendas\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor'\n * @returns {Promise<Array>} Legendas migradas\n */\nexport const migrarLegendasExistentes = async (escolaId, tipoFoto = 'escola') => {\n  try {\n    let imagens = [];\n    \n    if (tipoFoto === 'escola') {\n      // Buscar imagens existentes da tabela imagens_escola\n      const { data, error } = await supabase\n        .from('imagens_escola')\n        .select('*')\n        .eq('escola_id', escolaId)\n        .eq('ativo', true);\n\n      if (error) {\n        throw error;\n      }\n      imagens = data || [];\n    } else if (tipoFoto === 'professor') {\n      // Buscar imagens dos professores do bucket\n      const { data, error } = await supabase.storage\n        .from('imagens-professores')\n        .list(`${escolaId}/`);\n\n      if (error) {\n        throw error;\n      }\n      \n      imagens = (data || []).map(file => ({\n        url: `${escolaId}/${file.name}`,\n        descricao: `Imagem do professor - ${file.name}`,\n        created_at: file.created_at\n      }));\n    }\n\n    const legendasMigradas = [];\n\n    for (const imagem of imagens) {\n      // Verificar se já existe legenda para esta imagem\n      const legendaExistente = await getLegendaByImageUrl(imagem.url, escolaId, tipoFoto);\n      \n      if (!legendaExistente) {\n        // Criar nova legenda\n        const novaLegenda = await addLegendaFoto({\n          escola_id: escolaId,\n          imagem_url: imagem.url,\n          legenda: imagem.descricao || `Imagem da ${tipoFoto}`,\n          descricao_detalhada: imagem.descricao,\n          categoria: 'geral',\n          tipo_foto: tipoFoto,\n          ativo: true\n        });\n        \n        legendasMigradas.push(novaLegenda);\n      }\n    }\n\n    return legendasMigradas;\n  } catch (error) {\n    console.error('Erro ao migrar legendas existentes:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes de vídeos para títulos\n * @param {number} escolaId - ID da escola\n * @param {string} videoUrl - URL do vídeo\n * @returns {Promise<Object|null>} Título migrado\n */\nexport const migrarTituloExistente = async (escolaId, videoUrl) => {\n  try {\n    if (!videoUrl) return null;\n\n    // Verificar se já existe título para este vídeo\n    const tituloExistente = await getTituloByVideoUrl(videoUrl, escolaId);\n    \n    if (!tituloExistente) {\n      // Determinar plataforma\n      let plataforma = 'outro';\n      if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {\n        plataforma = 'youtube';\n      } else if (videoUrl.includes('vimeo.com')) {\n        plataforma = 'vimeo';\n      }\n\n      // Criar novo título\n      const novoTitulo = await addTituloVideo({\n        escola_id: escolaId,\n        video_url: videoUrl,\n        titulo: `Vídeo da Escola - ${plataforma.charAt(0).toUpperCase() + plataforma.slice(1)}`,\n        descricao: 'Vídeo relacionado à escola indígena',\n        plataforma: plataforma,\n        categoria: 'geral',\n        ativo: true\n      });\n      \n      return novoTitulo;\n    }\n\n    return tituloExistente;\n  } catch (error) {\n    console.error('Erro ao migrar título existente:', error);\n    throw error;\n  }\n};\n\n/**\n * Função de teste para verificar a estrutura da tabela legendas_fotos\n * @returns {Promise<void>}\n */\nexport const testLegendasTable = async () => {\n  try {\n    console.log('=== TESTE: Verificando estrutura da tabela legendas_fotos ===');\n    \n    // Teste 1: Verificar se a tabela existe\n    const { data: tableData, error: tableError } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .limit(1);\n    \n    console.log('Teste 1 - Tabela existe:', { tableData, tableError });\n    \n    if (tableError) {\n      console.error('❌ ERRO: Tabela legendas_fotos não existe ou não está acessível:', tableError);\n      return;\n    }\n    \n    // Teste 2: Verificar estrutura da tabela\n    const { data: structureData, error: structureError } = await supabase\n      .from('legendas_fotos')\n      .select('id, escola_id, imagem_url, legenda, descricao_detalhada, autor_foto, data_foto, categoria, ativo, created_at, updated_at')\n      .limit(1);\n    \n    console.log('Teste 2 - Estrutura da tabela:', { structureData, structureError });\n    \n    if (structureError) {\n      console.error('❌ ERRO: Problema com estrutura da tabela:', structureError);\n    } else {\n      console.log('✅ Estrutura básica da tabela está OK');\n    }\n    \n    // Teste 3: Verificar se a coluna tipo_foto existe\n    try {\n      const { data: tipoData, error: tipoError } = await supabase\n        .from('legendas_fotos')\n        .select('tipo_foto')\n        .limit(1);\n      \n      console.log('Teste 3 - Coluna tipo_foto:', { tipoData, tipoError });\n      \n      if (tipoError && tipoError.code === '42703') {\n        console.log('⚠️ AVISO: Coluna tipo_foto não existe na tabela');\n      } else if (tipoError) {\n        console.error('❌ ERRO: Problema com coluna tipo_foto:', tipoError);\n      } else {\n        console.log('✅ Coluna tipo_foto existe');\n      }\n    } catch (tipoError) {\n      console.log('⚠️ AVISO: Coluna tipo_foto não existe na tabela');\n    }\n    \n    // Teste 4: Tentar inserir um registro de teste\n    console.log('Teste 4 - Testando inserção...');\n    const testRecord = {\n      escola_id: 999999, // ID que não existe\n      imagem_url: 'test/test.jpg',\n      legenda: 'Teste de legenda',\n      descricao_detalhada: 'Descrição de teste',\n      autor_foto: 'Teste',\n      data_foto: '2024-01-01',\n      categoria: 'teste',\n      ativo: true,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n    \n    try {\n      const { data: insertData, error: insertError } = await supabase\n        .from('legendas_fotos')\n        .insert([testRecord])\n        .select()\n        .single();\n      \n      console.log('Teste 4 - Inserção de teste:', { insertData, insertError });\n      \n      if (insertError) {\n        console.error('❌ ERRO: Problema com inserção:', insertError);\n      } else {\n        console.log('✅ Inserção funcionando - removendo registro de teste...');\n        \n        // Remover o registro de teste\n        const { error: deleteError } = await supabase\n          .from('legendas_fotos')\n          .delete()\n          .eq('id', insertData.id);\n        \n        if (deleteError) {\n          console.error('⚠️ AVISO: Não foi possível remover registro de teste:', deleteError);\n        } else {\n          console.log('✅ Registro de teste removido com sucesso');\n        }\n      }\n    } catch (insertError) {\n      console.error('❌ ERRO: Falha na inserção de teste:', insertError);\n    }\n    \n    console.log('=== FIM DO TESTE ===');\n    \n  } catch (error) {\n    console.error('❌ ERRO GERAL no teste da tabela:', error);\n  }\n}; \n ","import { supabase } from '../supabaseClient';\n\n// Configurações para imagens das histórias do professor\nconst HISTORIA_PROFESSOR_CONFIG = {\n  BUCKET_NAME: 'historia-professor-imagens',\n  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB\n  ALLOWED_TYPES: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'],\n  MAX_IMAGES_PER_HISTORIA: 1,\n  MIN_DIMENSIONS: { width: 200, height: 200 }\n};\n\n/**\n * Valida um arquivo de imagem\n * @param {File} file - Arquivo a ser validado\n * @returns {Object} Resultado da validação\n */\nconst validateImageFile = (file) => {\n  // Verificar tipo MIME\n  if (!HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.includes(file.type)) {\n    return {\n      isValid: false,\n      error: `Tipo de arquivo não suportado. Use apenas: ${HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1].toUpperCase()).join(', ')}`\n    };\n  }\n\n  // Verificar tamanho\n  if (file.size > HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE) {\n    return {\n      isValid: false,\n      error: `Arquivo muito grande. Tamanho máximo: ${HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB`\n    };\n  }\n\n  // Verificar extensão\n  const extension = file.name.split('.').pop().toLowerCase();\n  const allowedExtensions = HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1]);\n  if (!allowedExtensions.includes(extension)) {\n    return {\n      isValid: false,\n      error: `Extensão não permitida. Use apenas: ${allowedExtensions.join(', ')}`\n    };\n  }\n\n  return { isValid: true };\n};\n\n/**\n * Valida dimensões da imagem (opcional)\n * @param {File} file - Arquivo de imagem\n * @returns {Promise<boolean>} Se as dimensões são válidas\n */\nconst validateImageDimensions = (file) => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      const isValid = img.width >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.width &&\n                     img.height >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.height;\n      resolve(isValid);\n    };\n    img.onerror = () => resolve(false);\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Gera nome único para o arquivo\n * @param {File} file - Arquivo\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da história\n * @returns {string} Nome único do arquivo\n */\nconst generateUniqueFileName = (file, escolaId, historiaId) => {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  const extension = file.name.split('.').pop().toLowerCase();\n  return `historia_${historiaId}_${timestamp}_${random}.${extension}`;\n};\n\n/**\n * Buscar todas as histórias do professor de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de histórias\n */\nexport const getHistoriasProfessor = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Adicionar URLs públicas das imagens\n    const historiasComImagens = data.map((historia) => {\n      if (historia.imagem_url) {\n        try {\n          const { data: { publicUrl } } = supabase.storage\n            .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n            .getPublicUrl(historia.imagem_url);\n\n          return { ...historia, imagem_public_url: publicUrl };\n        } catch (err) {\n          return { ...historia, imagem_public_url: null, urlError: err.message };\n        }\n      }\n      return historia;\n    });\n\n    return historiasComImagens;\n\n  } catch (error) {\n    console.error('Erro ao buscar histórias do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Criar nova história do professor\n * @param {Object} historiaData - Dados da história\n * @returns {Promise<Object>} História criada\n */\nexport const createHistoriaProfessor = async (historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .insert([{\n        escola_id: historiaData.escola_id,\n        nome_professor: historiaData.nome_professor || null,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem || 1,\n        ativo: historiaData.ativo !== false\n      }])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    console.error('Erro ao criar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar história do professor\n * @param {number} historiaId - ID da história\n * @param {Object} historiaData - Dados atualizados\n * @returns {Promise<Object>} História atualizada\n */\nexport const updateHistoriaProfessor = async (historiaId, historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .update({\n        nome_professor: historiaData.nome_professor,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem,\n        ativo: historiaData.ativo,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    console.error('Erro ao atualizar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar história do professor\n * @param {number} historiaId - ID da história\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessor = async (historiaId) => {\n  try {\n    // Deletar a história\n    const { error: deleteError } = await supabase\n      .from('historias_professor')\n      .delete()\n      .eq('id', historiaId);\n\n    if (deleteError) {\n      throw deleteError;\n    }\n  } catch (error) {\n    console.error('Erro ao deletar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Upload de imagem para uma história do professor\n * @param {File} file - Arquivo de imagem\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da história\n * @param {string} descricao - Descrição da imagem\n * @returns {Promise<Object>} Dados da imagem salva\n */\nexport const uploadHistoriaProfessorImage = async (file, escolaId, historiaId, descricao = '') => {\n  try {\n    // Validar arquivo\n    const validation = validateImageFile(file);\n    if (!validation.isValid) {\n      throw new Error(validation.error);\n    }\n\n    // Validar dimensões (opcional)\n    const hasValidDimensions = await validateImageDimensions(file);\n    if (!hasValidDimensions) {\n      console.warn('Imagem com dimensões menores que o recomendado');\n    }\n\n    // Gerar nome único\n    const fileName = generateUniqueFileName(file, escolaId, historiaId);\n    const filePath = `${escolaId}/${fileName}`;\n\n    // Upload ao bucket\n    const { error: uploadError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false\n      });\n\n    if (uploadError) {\n      throw new Error(`Erro no upload: ${uploadError.message}`);\n    }\n\n    // Obter URL pública\n    const { data: { publicUrl } } = supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .getPublicUrl(filePath);\n\n    // Atualizar a história com a URL da imagem\n    const { data: historia, error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: descricao.trim() || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (updateError) {\n      // Se falhar ao atualizar, deletar o arquivo\n      await supabase.storage\n        .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n        .remove([filePath]);\n      throw new Error(`Erro ao salvar metadados: ${updateError.message}`);\n    }\n\n    return {\n      id: historia.id,\n      descricao_imagem: historia.descricao_imagem\n    };\n\n  } catch (error) {\n    console.error('Erro no upload da imagem da história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar imagem de uma história do professor\n * @param {number} historiaId - ID da história\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessorImage = async (historiaId) => {\n  try {\n    // Buscar a história para obter a URL da imagem\n    const { data: historia, error: fetchError } = await supabase\n      .from('historias_professor')\n      .select('imagem_url')\n      .eq('id', historiaId)\n      .single();\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!historia.imagem_url) {\n      return; // Não há imagem para deletar\n    }\n\n    // Atualizar a história removendo a referência da imagem\n    const { error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId);\n\n    if (updateError) {\n      throw updateError;\n    }\n\n    // Deletar arquivo do storage\n    const { error: storageError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .remove([historia.imagem_url]);\n\n    if (storageError) {\n      console.warn('Erro ao deletar imagem do storage:', storageError);\n    }\n\n  } catch (error) {\n    console.error('Erro ao deletar imagem da história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes da tabela escolas_completa\n * @returns {Promise<Object>} Resultado da migração\n */\nexport const migrarDadosExistentes = async () => {\n  try {\n    // Buscar escolas com história do professor\n    const { data: escolas, error: fetchError } = await supabase\n      .from('escolas_completa')\n      .select('id, historia_do_prof')\n      .not('historia_do_prof', 'is', null)\n      .neq('historia_do_prof', '');\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!escolas || escolas.length === 0) {\n      return { migradas: 0, mensagem: 'Nenhuma história para migrar' };\n    }\n\n    // Inserir histórias na nova tabela\n    const historiasParaInserir = escolas.map(escola => ({\n      escola_id: escola.id,\n      historia: escola.historia_do_prof,\n      ordem: 1,\n      ativo: true,\n      created_at: new Date().toISOString()\n    }));\n\n    const { data: historiasInseridas, error: insertError } = await supabase\n      .from('historias_professor')\n      .insert(historiasParaInserir)\n      .select();\n\n    if (insertError) {\n      throw insertError;\n    }\n\n    return {\n      migradas: historiasInseridas.length,\n      mensagem: `${historiasInseridas.length} histórias migradas com sucesso`\n    };\n\n  } catch (error) {\n    console.error('Erro na migração de dados:', error);\n    throw error;\n  }\n};\n\n/**\n * Verificar se uma escola tem histórias do professor\n * @param {number} escolaId - ID da escola\n * @returns {Promise<boolean>} Se tem histórias\n */\nexport const escolaTemHistoriasProfessor = async (escolaId) => {\n  try {\n    const { count, error } = await supabase\n      .from('historias_professor')\n      .select('*', { count: 'exact', head: true })\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (error) {\n      throw error;\n    }\n\n    return (count || 0) > 0;\n\n  } catch (error) {\n    console.error('Erro ao verificar histórias do professor:', error);\n    return false;\n  }\n}; "],"names":["addLegendaFoto","async","console","log","legenda","legendaData","_objectSpread","data","testData","error","testError","supabase","from","select","limit","code","warn","tipo_foto","columnError","insert","single","updateLegendaFoto","id","updates","update","eq","getLegendaByImageUrl","imagemUrl","escolaId","tipoFoto","arguments","length","undefined","query","caminhoRelativo","split","slice","join","query2","ilike","concat","data2","error2","getTituloByVideoUrl","videoUrl","testLegendasTable","tableData","tableError","structureData","structureError","tipoData","tipoError","testRecord","escola_id","imagem_url","descricao_detalhada","autor_foto","data_foto","categoria","ativo","created_at","Date","toISOString","updated_at","insertData","insertError","deleteError","delete","HISTORIA_PROFESSOR_CONFIG","BUCKET_NAME","MAX_FILE_SIZE","ALLOWED_TYPES","MAX_IMAGES_PER_HISTORIA","MIN_DIMENSIONS","width","height","getHistoriasProfessor","order","ascending","map","historia","publicUrl","storage","getPublicUrl","imagem_public_url","err","urlError","message","createHistoriaProfessor","historiaData","nome_professor","ordem","updateHistoriaProfessor","historiaId","deleteHistoriaProfessor"],"sourceRoot":""}