{"version":3,"file":"static/js/236.707b8dc5.chunk.js","mappings":"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","sources":["services/legendasService.js","components/AdminPanel/constants/cardVisibilityConfig.js","services/historiaProfessorService.js","services/videoService.js","services/globalConfigService.js","hooks/useGlobalCardVisibility.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\nimport logger from '../utils/logger';\n\n/**\n * Servi√ßo para gerenciar legendas de fotos\n */\n\n/**\n * Testar se a tabela legendas_fotos existe e est√° acess√≠vel\n * @returns {Promise<boolean>} True se a tabela existe\n */\nexport const testLegendasTable = async () => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .select('count')\n      .limit(1);\n    \n    if (error) {\n      logger.warn('Tabela legendas_fotos n√£o encontrada ou sem permiss√£o:', error.message);\n      return false;\n    }\n    \n    logger.debug('Tabela legendas_fotos acess√≠vel');\n    return true;\n  } catch (error) {\n    logger.warn('Erro ao testar tabela legendas_fotos:', error.message);\n    return false;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (todos os atributos opcionais)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} options - Op√ß√µes de busca (todos opcionais)\n * @param {string} options.categoria - Categoria da imagem\n * @param {string} options.tipo_foto - Tipo da foto\n * @param {boolean} options.ativo - Se deve buscar apenas ativas\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imageUrl, escolaId, options = {}) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId);\n\n    // Aplicar filtros opcionais\n    if (options.ativo !== false) { // Por padr√£o, busca apenas ativas\n      query = query.eq('ativo', true);\n    }\n    \n    if (options.categoria) {\n      query = query.eq('categoria', options.categoria);\n    }\n    \n    if (options.tipo_foto) {\n      query = query.eq('tipo_foto', options.tipo_foto);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      logger.warn('Erro ao buscar legenda:', error.message);\n      return null;\n    }\n\n    // Retorna a primeira legenda encontrada (mais recente)\n    return data && data.length > 0 ? data[0] : null;\n  } catch (error) {\n    logger.warn('Erro ao buscar legenda:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (busca flex√≠vel com m√∫ltiplas estrat√©gias)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} preferencias - Prefer√™ncias de busca (todos opcionais)\n * @param {string} preferencias.categoria - Categoria preferida\n * @param {string} preferencias.tipo_foto - Tipo de foto preferido\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlFlexivel = async (imageUrl, escolaId, preferencias = {}) => {\n  try {\n    logger.debug(`üîç Buscando legenda flex√≠vel para: ${imageUrl} (escola: ${escolaId})`);\n    \n    // Estrat√©gia 1: Busca com prefer√™ncias espec√≠ficas\n    if (preferencias.categoria || preferencias.tipo_foto) {\n      logger.debug('  üìã Tentativa 1: Busca com prefer√™ncias espec√≠ficas');\n      const legenda = await getLegendaByImageUrl(imageUrl, escolaId, preferencias);\n      if (legenda) {\n        logger.debug('  ‚úÖ Encontrada com prefer√™ncias espec√≠ficas');\n        return legenda;\n      }\n    }\n\n    // Estrat√©gia 2: Busca apenas por URL e escola (sem outros filtros)\n    logger.debug('  üìã Tentativa 2: Busca apenas por URL e escola');\n    const { data: data2, error: error2 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error2) {\n      logger.warn('  ‚ùå Erro na busca por URL e escola:', error2.message);\n    } else if (data2 && data2.length > 0) {\n      logger.debug('  ‚úÖ Encontrada por URL e escola');\n      return data2[0];\n    }\n\n    // Estrat√©gia 3: Busca incluindo legendas inativas\n    logger.debug('  üìã Tentativa 3: Busca incluindo legendas inativas');\n    const { data: data3, error: error3 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .order('created_at', { ascending: false });\n\n    if (error3) {\n      logger.warn('  ‚ùå Erro na busca incluindo inativas:', error3.message);\n    } else if (data3 && data3.length > 0) {\n      logger.debug('  ‚úÖ Encontrada incluindo legendas inativas');\n      return data3[0];\n    }\n\n    // Estrat√©gia 4: Busca por nome do arquivo (sem caminho completo)\n    const nomeArquivo = imageUrl.split('/').pop();\n    logger.debug(`  üìã Tentativa 4: Busca por nome do arquivo: ${nomeArquivo}`);\n    const { data: data4, error: error4 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .ilike('imagem_url', `%${nomeArquivo}`)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error4) {\n      logger.warn('  ‚ùå Erro na busca por nome do arquivo:', error4.message);\n    } else if (data4 && data4.length > 0) {\n      logger.debug('  ‚úÖ Encontrada por nome do arquivo');\n      return data4[0];\n    }\n\n    logger.debug('  ‚ùå Nenhuma legenda encontrada com todas as estrat√©gias');\n    return null;\n\n  } catch (error) {\n    logger.warn('Erro ao buscar legenda flex√≠vel:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (sem filtro de categoria) - MANTIDA PARA COMPATIBILIDADE\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlAnyCategory = async (imageUrl, escolaId) => {\n  return getLegendaByImageUrlFlexivel(imageUrl, escolaId);\n};\n\n/**\n * Adicionar nova legenda de foto\n * @param {Object} legendaData - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legendaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    logger.error('Erro ao adicionar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto existente\n * @param {number} legendaId - ID da legenda\n * @param {Object} updateData - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (legendaId, updateData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(updateData)\n      .eq('id', legendaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    logger.error('Erro ao atualizar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto\n * @param {number} legendaId - ID da legenda\n * @returns {Promise<boolean>} True se deletado com sucesso\n */\nexport const deleteLegendaFoto = async (legendaId) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .delete()\n      .eq('id', legendaId);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    logger.error('Erro ao deletar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} categoria - Categoria das imagens (opcional)\n * @returns {Promise<Array>} Lista de legendas\n */\nexport const getLegendasByEscola = async (escolaId, categoria = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId);\n\n    if (categoria) {\n      query = query.eq('categoria', categoria);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    logger.error('Erro ao buscar legendas da escola:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar t√≠tulo personalizado de v√≠deo por URL\n * @param {string} videoUrl - URL do v√≠deo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} T√≠tulo encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('categoria', 'video')\n      .single();\n\n    if (error) {\n      // Se n√£o encontrar, retorna null (n√£o √© erro)\n      if (error.code === 'PGRST116') {\n        return null;\n      }\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    logger.warn('Erro ao buscar t√≠tulo do v√≠deo:', error.message);\n    return null;\n  }\n};\n\n/**\n * Atualizar ordem de uma imagem\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {number} ordem - Nova ordem\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateImageOrder = async (imageUrl, escolaId, ordem) => {\n  try {\n    // Primeiro, buscar a legenda existente\n    const legenda = await getLegendaByImageUrl(imageUrl, escolaId, { ativo: false });\n    \n    if (legenda) {\n      // Se existe, atualizar apenas a ordem\n      const { data, error } = await supabase\n        .from('legendas_fotos')\n        .update({ ordem, updated_at: new Date().toISOString() })\n        .eq('id', legenda.id)\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } else {\n      // Se n√£o existe, criar uma entrada b√°sica com ordem\n      // Extrair nome do arquivo para usar como legenda padr√£o\n      const fileName = imageUrl.split('/').pop() || 'Imagem';\n      const legendaPadrao = fileName.replace(/\\.[^/.]+$/, '').replace(/[_-]/g, ' ') || 'Imagem';\n      \n      const { data, error } = await supabase\n        .from('legendas_fotos')\n        .insert([{\n          escola_id: escolaId,\n          imagem_url: imageUrl,\n          legenda: legendaPadrao, // Valor padr√£o obrigat√≥rio\n          ordem,\n          ativo: true,\n          tipo_foto: 'escola',\n          categoria: 'geral',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        }])\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    }\n  } catch (error) {\n    logger.error('Erro ao atualizar ordem da imagem:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar ordem de m√∫ltiplas imagens\n * @param {Array} imageOrders - Array de objetos { imageUrl, ordem }\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Legendas atualizadas\n */\nexport const updateMultipleImageOrders = async (imageOrders, escolaId) => {\n  try {\n    const updates = await Promise.all(\n      imageOrders.map(({ imageUrl, ordem }) => \n        updateImageOrder(imageUrl, escolaId, ordem)\n      )\n    );\n    return updates;\n  } catch (error) {\n    logger.error('Erro ao atualizar ordens das imagens:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola ordenadas por ordem\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - Tipo da foto (opcional, default: 'escola')\n * @returns {Promise<Array>} Lista de legendas ordenadas\n */\nexport const getLegendasByEscolaOrdered = async (escolaId, tipoFoto = 'escola') => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('tipo_foto', tipoFoto)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true, nullsFirst: false })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    logger.error('Erro ao buscar legendas ordenadas da escola:', error);\n    throw error;\n  }\n};\n\nconst LegendasService = {\n  testLegendasTable,\n  getLegendaByImageUrl,\n  getLegendaByImageUrlFlexivel,\n  getLegendaByImageUrlAnyCategory,\n  addLegendaFoto,\n  updateLegendaFoto,\n  deleteLegendaFoto,\n  getLegendasByEscola,\n  getTituloByVideoUrl,\n  updateImageOrder,\n  updateMultipleImageOrders,\n  getLegendasByEscolaOrdered\n};\n\nexport default LegendasService;\n","// Configura√ß√£o dos cards dispon√≠veis para controle de visibilidade\nexport const CARD_VISIBILITY_CONFIG = [\n  {\n    id: 'basicInfo',\n    label: 'Informa√ß√µes B√°sicas',\n    description: 'Nome, munic√≠pio, endere√ßo, terra ind√≠gena',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'modalidades',\n    label: 'Modalidades de Ensino',\n    description: 'Modalidades e turnos de funcionamento',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'infraestrutura',\n    label: 'Infraestrutura',\n    description: 'Estrutura f√≠sica, √°gua, internet, equipamentos',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'gestaoProfessores',\n    label: 'Gest√£o e Professores',\n    description: 'Dire√ß√£o, professores, forma√ß√£o profissional',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'projetosParcerias',\n    label: 'Projetos e Parcerias',\n    description: 'Projetos, parcerias, ONGs, desejos da comunidade',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'historiaEscola',\n    label: 'Hist√≥ria da Escola',\n    description: 'Hist√≥ria e contexto da escola',\n    defaultVisible: true,\n    category: 'standalone'\n  },\n  {\n    id: 'imagensEscola',\n    label: 'Imagens da Escola',\n    description: 'Galeria de fotos da escola',\n    defaultVisible: true,\n    category: 'standalone'\n  },\n  {\n    id: 'historiaProfessor',\n    label: 'Hist√≥ria dos Professores',\n    description: 'Depoimentos e hist√≥rias dos professores',\n    defaultVisible: true,\n    category: 'standalone'\n  },\n  {\n    id: 'documentos',\n    label: 'Documentos',\n    description: 'PDFs e documentos da escola',\n    defaultVisible: true,\n    category: 'standalone'\n  },\n  {\n    id: 'videos',\n    label: 'V√≠deos',\n    description: 'V√≠deos e produ√ß√µes audiovisuais',\n    defaultVisible: true,\n    category: 'standalone'\n  }\n];\n\n// Fun√ß√£o helper para obter visibilidade padr√£o\nexport const getDefaultVisibility = () => {\n  return CARD_VISIBILITY_CONFIG.reduce((acc, card) => {\n    acc[card.id] = card.defaultVisible;\n    return acc;\n  }, {});\n};\n\n// Fun√ß√£o helper para obter visibilidade de um card espec√≠fico\n// Considera primeiro a configura√ß√£o individual da escola, depois a global\nexport const isCardVisible = (cardsVisibilidade, cardId, globalVisibility = null) => {\n  // Se a escola tem configura√ß√£o individual para este card, usa ela\n  if (cardsVisibilidade && cardsVisibilidade.hasOwnProperty(cardId)) {\n    return cardsVisibilidade[cardId] !== false;\n  }\n  \n  // Se n√£o tem configura√ß√£o individual, usa a global\n  if (globalVisibility && globalVisibility.hasOwnProperty(cardId)) {\n    return globalVisibility[cardId] !== false;\n  }\n  \n  // Default: vis√≠vel\n  return true;\n};\n\n","import { supabase } from '../supabaseClient';\nimport logger from '../utils/logger';\n\n// Configura√ß√µes para imagens das hist√≥rias do professor\nconst HISTORIA_PROFESSOR_CONFIG = {\n  BUCKET_NAME: 'historia-professor-imagens',\n  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB\n  ALLOWED_TYPES: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'],\n  MAX_IMAGES_PER_HISTORIA: 1,\n  MIN_DIMENSIONS: { width: 200, height: 200 }\n};\n\n/**\n * Valida um arquivo de imagem\n * @param {File} file - Arquivo a ser validado\n * @returns {Object} Resultado da valida√ß√£o\n */\nconst validateImageFile = (file) => {\n  // Verificar tipo MIME\n  if (!HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.includes(file.type)) {\n    return {\n      isValid: false,\n      error: `Tipo de arquivo n√£o suportado. Use apenas: ${HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1].toUpperCase()).join(', ')}`\n    };\n  }\n\n  // Verificar tamanho\n  if (file.size > HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE) {\n    return {\n      isValid: false,\n      error: `Arquivo muito grande. Tamanho m√°ximo: ${HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB`\n    };\n  }\n\n  // Verificar extens√£o\n  const extension = file.name.split('.').pop().toLowerCase();\n  const allowedExtensions = HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1]);\n  if (!allowedExtensions.includes(extension)) {\n    return {\n      isValid: false,\n      error: `Extens√£o n√£o permitida. Use apenas: ${allowedExtensions.join(', ')}`\n    };\n  }\n\n  return { isValid: true };\n};\n\n/**\n * Valida dimens√µes da imagem (opcional)\n * @param {File} file - Arquivo de imagem\n * @returns {Promise<boolean>} Se as dimens√µes s√£o v√°lidas\n */\nconst validateImageDimensions = (file) => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      const isValid = img.width >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.width &&\n                     img.height >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.height;\n      resolve(isValid);\n    };\n    img.onerror = () => resolve(false);\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Gera nome √∫nico para o arquivo\n * @param {File} file - Arquivo\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {string} Nome √∫nico do arquivo\n */\nconst generateUniqueFileName = (file, escolaId, historiaId) => {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  const extension = file.name.split('.').pop().toLowerCase();\n  return `historia_${historiaId}_${timestamp}_${random}.${extension}`;\n};\n\n/**\n * Buscar todas as hist√≥rias do professor de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de hist√≥rias\n */\nexport const getHistoriasProfessor = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Adicionar URLs p√∫blicas das imagens\n    const historiasComImagens = data.map((historia) => {\n      if (historia.imagem_url) {\n        try {\n          const { data: { publicUrl } } = supabase.storage\n            .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n            .getPublicUrl(historia.imagem_url);\n\n          return { ...historia, imagem_public_url: publicUrl };\n        } catch (err) {\n          return { ...historia, imagem_public_url: null, urlError: err.message };\n        }\n      }\n      return historia;\n    });\n\n    return historiasComImagens;\n\n  } catch (error) {\n    logger.error('Erro ao buscar hist√≥rias do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Criar nova hist√≥ria do professor\n * @param {Object} historiaData - Dados da hist√≥ria\n * @returns {Promise<Object>} Hist√≥ria criada\n */\nexport const createHistoriaProfessor = async (historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .insert([{\n        escola_id: historiaData.escola_id,\n        nome_professor: historiaData.nome_professor || null,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem || 1,\n        ativo: historiaData.ativo !== false,\n        foto_rosto: historiaData.foto_rosto || null\n      }])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    logger.error('Erro ao criar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @param {Object} historiaData - Dados atualizados\n * @returns {Promise<Object>} Hist√≥ria atualizada\n */\nexport const updateHistoriaProfessor = async (historiaId, historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .update({\n        nome_professor: historiaData.nome_professor,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem,\n        ativo: historiaData.ativo,\n        foto_rosto: historiaData.foto_rosto || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    logger.error('Erro ao atualizar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessor = async (historiaId) => {\n  try {\n    // Deletar a hist√≥ria\n    const { error: deleteError } = await supabase\n      .from('historias_professor')\n      .delete()\n      .eq('id', historiaId);\n\n    if (deleteError) {\n      throw deleteError;\n    }\n  } catch (error) {\n    logger.error('Erro ao deletar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Upload de imagem para uma hist√≥ria do professor\n * @param {File} file - Arquivo de imagem\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da hist√≥ria\n * @param {string} descricao - Descri√ß√£o da imagem\n * @returns {Promise<Object>} Dados da imagem salva\n */\nexport const uploadHistoriaProfessorImage = async (file, escolaId, historiaId, descricao = '') => {\n  try {\n    // Validar arquivo\n    const validation = validateImageFile(file);\n    if (!validation.isValid) {\n      throw new Error(validation.error);\n    }\n\n    // Validar dimens√µes (opcional)\n    const hasValidDimensions = await validateImageDimensions(file);\n    if (!hasValidDimensions) {\n      logger.warn('Imagem com dimens√µes menores que o recomendado');\n    }\n\n    // Gerar nome √∫nico\n    const fileName = generateUniqueFileName(file, escolaId, historiaId);\n    const filePath = `${escolaId}/${fileName}`;\n\n    // Upload ao bucket\n    const { error: uploadError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false\n      });\n\n    if (uploadError) {\n      throw new Error(`Erro no upload: ${uploadError.message}`);\n    }\n\n    // Obter URL p√∫blica - n√£o usado\n    // const { data: { publicUrl } } = supabase.storage\n    //   .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n    //   .getPublicUrl(filePath);\n\n    // Atualizar a hist√≥ria com a URL da imagem\n    const { data: historia, error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: descricao.trim() || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (updateError) {\n      // Se falhar ao atualizar, deletar o arquivo\n      await supabase.storage\n        .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n        .remove([filePath]);\n      throw new Error(`Erro ao salvar metadados: ${updateError.message}`);\n    }\n\n    return {\n      id: historia.id,\n      descricao_imagem: historia.descricao_imagem\n    };\n\n  } catch (error) {\n    logger.error('Erro no upload da imagem da hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar imagem de uma hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessorImage = async (historiaId) => {\n  try {\n    // Buscar a hist√≥ria para obter a URL da imagem\n    const { data: historia, error: fetchError } = await supabase\n      .from('historias_professor')\n      .select('imagem_url')\n      .eq('id', historiaId)\n      .single();\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!historia.imagem_url) {\n      return; // N√£o h√° imagem para deletar\n    }\n\n    // Atualizar a hist√≥ria removendo a refer√™ncia da imagem\n    const { error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId);\n\n    if (updateError) {\n      throw updateError;\n    }\n\n    // Deletar arquivo do storage\n    const { error: storageError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .remove([historia.imagem_url]);\n\n    if (storageError) {\n      logger.warn('Erro ao deletar imagem do storage:', storageError);\n    }\n\n  } catch (error) {\n    logger.error('Erro ao deletar imagem da hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes da tabela escolas_completa\n * @returns {Promise<Object>} Resultado da migra√ß√£o\n */\nexport const migrarDadosExistentes = async () => {\n  try {\n    // Buscar escolas com hist√≥ria do professor\n    const { data: escolas, error: fetchError } = await supabase\n      .from('escolas_completa')\n      .select('id, historia_do_prof')\n      .not('historia_do_prof', 'is', null)\n      .neq('historia_do_prof', '');\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!escolas || escolas.length === 0) {\n      return { migradas: 0, mensagem: 'Nenhuma hist√≥ria para migrar' };\n    }\n\n    // Inserir hist√≥rias na nova tabela\n    const historiasParaInserir = escolas.map(escola => ({\n      escola_id: escola.id,\n      historia: escola.historia_do_prof,\n      ordem: 1,\n      ativo: true,\n      created_at: new Date().toISOString()\n    }));\n\n    const { data: historiasInseridas, error: insertError } = await supabase\n      .from('historias_professor')\n      .insert(historiasParaInserir)\n      .select();\n\n    if (insertError) {\n      throw insertError;\n    }\n\n    return {\n      migradas: historiasInseridas.length,\n      mensagem: `${historiasInseridas.length} hist√≥rias migradas com sucesso`\n    };\n\n  } catch (error) {\n    logger.error('Erro na migra√ß√£o de dados:', error);\n    throw error;\n  }\n};\n\n/**\n * Verificar se uma escola tem hist√≥rias do professor\n * @param {number} escolaId - ID da escola\n * @returns {Promise<boolean>} Se tem hist√≥rias\n */\nexport const escolaTemHistoriasProfessor = async (escolaId) => {\n  try {\n    const { count, error } = await supabase\n      .from('historias_professor')\n      .select('*', { count: 'exact', head: true })\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (error) {\n      throw error;\n    }\n\n    return (count || 0) > 0;\n\n  } catch (error) {\n    logger.error('Erro ao verificar hist√≥rias do professor:', error);\n    return false;\n  }\n}; ","import { supabase } from '../supabaseClient';\n\n// Buscar todos os v√≠deos de uma escola\nexport async function getVideosEscola(escolaId) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .select('*')\n    .eq('escola_id', escolaId)\n    .eq('ativo', true)\n    .order('created_at', { ascending: false });\n  if (error) throw error;\n  return data;\n}\n\n// Criar novo v√≠deo\nexport async function createVideoEscola(video) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .insert([video])\n    .select();\n  if (error) throw error;\n  return data?.[0];\n}\n\n// Atualizar v√≠deo existente\nexport async function updateVideoEscola(id, updates) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .update(updates)\n    .eq('id', id)\n    .select();\n  if (error) throw error;\n  return data?.[0];\n}\n\n// Remover v√≠deo\nexport async function deleteVideoEscola(id) {\n  const { error } = await supabase\n    .from('titulos_videos')\n    .delete()\n    .eq('id', id);\n  if (error) throw error;\n  return true;\n} ","import { supabase } from '../supabaseClient';\nimport logger from '../utils/logger';\n\n/**\n * Servi√ßo para gerenciar configura√ß√µes globais do sistema\n */\nexport class GlobalConfigService {\n  /**\n   * Obter configura√ß√£o global de visibilidade de cards\n   * @returns {Promise<Object|null>} Configura√ß√£o de visibilidade ou null se n√£o encontrada\n   */\n  static async getGlobalCardsVisibility() {\n    try {\n      const { data, error } = await supabase\n        .from('configuracao_global')\n        .select('valor')\n        .eq('chave', 'cards_visibilidade_global')\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          // N√£o encontrado - retornar null para usar padr√µes\n          return null;\n        }\n        throw error;\n      }\n\n      return data?.valor || null;\n    } catch (error) {\n      logger.error('Erro ao buscar configura√ß√£o global de visibilidade:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Salvar configura√ß√£o global de visibilidade de cards\n   * @param {Object} visibilityConfig - Configura√ß√£o de visibilidade\n   * @returns {Promise<Object>} Resultado da opera√ß√£o\n   */\n  static async saveGlobalCardsVisibility(visibilityConfig) {\n    try {\n      const { data, error } = await supabase\n        .from('configuracao_global')\n        .upsert({\n          chave: 'cards_visibilidade_global',\n          valor: visibilityConfig,\n          descricao: 'Configura√ß√£o padr√£o de visibilidade de cards para todas as escolas',\n          updated_at: new Date().toISOString()\n        }, {\n          onConflict: 'chave'\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        data: data\n      };\n    } catch (error) {\n      logger.error('Erro ao salvar configura√ß√£o global de visibilidade:', error);\n      return {\n        success: false,\n        error: error.message || 'Erro ao salvar configura√ß√£o global'\n      };\n    }\n  }\n}\n\n","import { useState, useEffect } from 'react';\nimport { GlobalConfigService } from '../services/globalConfigService';\n\n/**\n * Hook para buscar e gerenciar a configura√ß√£o global de visibilidade de cards\n * @returns {Object} { globalVisibility, loading }\n */\nexport const useGlobalCardVisibility = () => {\n  const [globalVisibility, setGlobalVisibility] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const loadGlobalConfig = async () => {\n      try {\n        setLoading(true);\n        const config = await GlobalConfigService.getGlobalCardsVisibility();\n        setGlobalVisibility(config);\n      } catch (error) {\n        console.error('Erro ao carregar configura√ß√£o global:', error);\n        setGlobalVisibility(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadGlobalConfig();\n  }, []);\n\n  return { globalVisibility, loading };\n};\n\n\n\n\n\n"],"names":["testLegendasTable","async","error","supabase","from","select","limit","logger","warn","message","debug","getLegendaByImageUrl","imageUrl","escolaId","options","arguments","length","undefined","query","eq","ativo","categoria","tipo_foto","data","order","ascending","getLegendaByImageUrlFlexivel","preferencias","concat","legenda","data2","error2","data3","error3","nomeArquivo","split","pop","data4","error4","ilike","addLegendaFoto","insert","legendaData","single","updateLegendaFoto","legendaId","updateData","update","getTituloByVideoUrl","videoUrl","code","updateImageOrder","ordem","updated_at","Date","toISOString","id","legendaPadrao","replace","escola_id","imagem_url","created_at","updateMultipleImageOrders","imageOrders","Promise","all","map","_ref","CARD_VISIBILITY_CONFIG","label","description","defaultVisible","category","getDefaultVisibility","reduce","acc","card","isCardVisible","cardsVisibilidade","cardId","globalVisibility","hasOwnProperty","HISTORIA_PROFESSOR_CONFIG","BUCKET_NAME","MAX_FILE_SIZE","ALLOWED_TYPES","MAX_IMAGES_PER_HISTORIA","MIN_DIMENSIONS","width","height","getHistoriasProfessor","historia","publicUrl","storage","getPublicUrl","_objectSpread","imagem_public_url","err","urlError","createHistoriaProfessor","historiaData","nome_professor","foto_rosto","updateHistoriaProfessor","historiaId","deleteHistoriaProfessor","deleteError","delete","getVideosEscola","createVideoEscola","video","updateVideoEscola","updates","deleteVideoEscola","GlobalConfigService","getGlobalCardsVisibility","valor","saveGlobalCardsVisibility","visibilityConfig","upsert","chave","descricao","onConflict","success","useGlobalCardVisibility","setGlobalVisibility","useState","loading","setLoading","useEffect","config","console","loadGlobalConfig"],"sourceRoot":""}