{"version":3,"file":"static/js/966.e1eb046f.chunk.js","mappings":"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","sources":["services/legendasService.js","services/historiaProfessorService.js","services/videoService.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\n\n/**\n * Servi√ßo para gerenciar legendas de fotos\n */\n\n/**\n * Testar se a tabela legendas_fotos existe e est√° acess√≠vel\n * @returns {Promise<boolean>} True se a tabela existe\n */\nexport const testLegendasTable = async () => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .select('count')\n      .limit(1);\n    \n    if (error) {\n      console.warn('Tabela legendas_fotos n√£o encontrada ou sem permiss√£o:', error.message);\n      return false;\n    }\n    \n    console.log('Tabela legendas_fotos acess√≠vel');\n    return true;\n  } catch (error) {\n    console.warn('Erro ao testar tabela legendas_fotos:', error.message);\n    return false;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (todos os atributos opcionais)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} options - Op√ß√µes de busca (todos opcionais)\n * @param {string} options.categoria - Categoria da imagem\n * @param {string} options.tipo_foto - Tipo da foto\n * @param {boolean} options.ativo - Se deve buscar apenas ativas\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imageUrl, escolaId, options = {}) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId);\n\n    // Aplicar filtros opcionais\n    if (options.ativo !== false) { // Por padr√£o, busca apenas ativas\n      query = query.eq('ativo', true);\n    }\n    \n    if (options.categoria) {\n      query = query.eq('categoria', options.categoria);\n    }\n    \n    if (options.tipo_foto) {\n      query = query.eq('tipo_foto', options.tipo_foto);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      console.warn('Erro ao buscar legenda:', error.message);\n      return null;\n    }\n\n    // Retorna a primeira legenda encontrada (mais recente)\n    return data && data.length > 0 ? data[0] : null;\n  } catch (error) {\n    console.warn('Erro ao buscar legenda:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (busca flex√≠vel com m√∫ltiplas estrat√©gias)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} preferencias - Prefer√™ncias de busca (todos opcionais)\n * @param {string} preferencias.categoria - Categoria preferida\n * @param {string} preferencias.tipo_foto - Tipo de foto preferido\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlFlexivel = async (imageUrl, escolaId, preferencias = {}) => {\n  try {\n    console.log(`üîç Buscando legenda flex√≠vel para: ${imageUrl} (escola: ${escolaId})`);\n    \n    // Estrat√©gia 1: Busca com prefer√™ncias espec√≠ficas\n    if (preferencias.categoria || preferencias.tipo_foto) {\n      console.log('  üìã Tentativa 1: Busca com prefer√™ncias espec√≠ficas');\n      const legenda = await getLegendaByImageUrl(imageUrl, escolaId, preferencias);\n      if (legenda) {\n        console.log('  ‚úÖ Encontrada com prefer√™ncias espec√≠ficas');\n        return legenda;\n      }\n    }\n\n    // Estrat√©gia 2: Busca apenas por URL e escola (sem outros filtros)\n    console.log('  üìã Tentativa 2: Busca apenas por URL e escola');\n    const { data: data2, error: error2 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error2) {\n      console.warn('  ‚ùå Erro na busca por URL e escola:', error2.message);\n    } else if (data2 && data2.length > 0) {\n      console.log('  ‚úÖ Encontrada por URL e escola');\n      return data2[0];\n    }\n\n    // Estrat√©gia 3: Busca incluindo legendas inativas\n    console.log('  üìã Tentativa 3: Busca incluindo legendas inativas');\n    const { data: data3, error: error3 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .order('created_at', { ascending: false });\n\n    if (error3) {\n      console.warn('  ‚ùå Erro na busca incluindo inativas:', error3.message);\n    } else if (data3 && data3.length > 0) {\n      console.log('  ‚úÖ Encontrada incluindo legendas inativas');\n      return data3[0];\n    }\n\n    // Estrat√©gia 4: Busca por nome do arquivo (sem caminho completo)\n    const nomeArquivo = imageUrl.split('/').pop();\n    console.log(`  üìã Tentativa 4: Busca por nome do arquivo: ${nomeArquivo}`);\n    const { data: data4, error: error4 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .ilike('imagem_url', `%${nomeArquivo}`)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error4) {\n      console.warn('  ‚ùå Erro na busca por nome do arquivo:', error4.message);\n    } else if (data4 && data4.length > 0) {\n      console.log('  ‚úÖ Encontrada por nome do arquivo');\n      return data4[0];\n    }\n\n    console.log('  ‚ùå Nenhuma legenda encontrada com todas as estrat√©gias');\n    return null;\n\n  } catch (error) {\n    console.warn('Erro ao buscar legenda flex√≠vel:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (sem filtro de categoria) - MANTIDA PARA COMPATIBILIDADE\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlAnyCategory = async (imageUrl, escolaId) => {\n  return getLegendaByImageUrlFlexivel(imageUrl, escolaId);\n};\n\n/**\n * Adicionar nova legenda de foto\n * @param {Object} legendaData - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legendaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto existente\n * @param {number} legendaId - ID da legenda\n * @param {Object} updateData - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (legendaId, updateData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(updateData)\n      .eq('id', legendaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto\n * @param {number} legendaId - ID da legenda\n * @returns {Promise<boolean>} True se deletado com sucesso\n */\nexport const deleteLegendaFoto = async (legendaId) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .delete()\n      .eq('id', legendaId);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} categoria - Categoria das imagens (opcional)\n * @returns {Promise<Array>} Lista de legendas\n */\nexport const getLegendasByEscola = async (escolaId, categoria = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId);\n\n    if (categoria) {\n      query = query.eq('categoria', categoria);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas da escola:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar t√≠tulo personalizado de v√≠deo por URL\n * @param {string} videoUrl - URL do v√≠deo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} T√≠tulo encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('categoria', 'video')\n      .single();\n\n    if (error) {\n      // Se n√£o encontrar, retorna null (n√£o √© erro)\n      if (error.code === 'PGRST116') {\n        return null;\n      }\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.warn('Erro ao buscar t√≠tulo do v√≠deo:', error.message);\n    return null;\n  }\n};\n\n/**\n * Atualizar ordem de uma imagem\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {number} ordem - Nova ordem\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateImageOrder = async (imageUrl, escolaId, ordem) => {\n  try {\n    // Primeiro, buscar a legenda existente\n    const legenda = await getLegendaByImageUrl(imageUrl, escolaId, { ativo: false });\n    \n    if (legenda) {\n      // Se existe, atualizar apenas a ordem\n      const { data, error } = await supabase\n        .from('legendas_fotos')\n        .update({ ordem, updated_at: new Date().toISOString() })\n        .eq('id', legenda.id)\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } else {\n      // Se n√£o existe, criar uma entrada b√°sica com ordem\n      // Extrair nome do arquivo para usar como legenda padr√£o\n      const fileName = imageUrl.split('/').pop() || 'Imagem';\n      const legendaPadrao = fileName.replace(/\\.[^/.]+$/, '').replace(/[_-]/g, ' ') || 'Imagem';\n      \n      const { data, error } = await supabase\n        .from('legendas_fotos')\n        .insert([{\n          escola_id: escolaId,\n          imagem_url: imageUrl,\n          legenda: legendaPadrao, // Valor padr√£o obrigat√≥rio\n          ordem,\n          ativo: true,\n          tipo_foto: 'escola',\n          categoria: 'geral',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        }])\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    }\n  } catch (error) {\n    console.error('Erro ao atualizar ordem da imagem:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar ordem de m√∫ltiplas imagens\n * @param {Array} imageOrders - Array de objetos { imageUrl, ordem }\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Legendas atualizadas\n */\nexport const updateMultipleImageOrders = async (imageOrders, escolaId) => {\n  try {\n    const updates = await Promise.all(\n      imageOrders.map(({ imageUrl, ordem }) => \n        updateImageOrder(imageUrl, escolaId, ordem)\n      )\n    );\n    return updates;\n  } catch (error) {\n    console.error('Erro ao atualizar ordens das imagens:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola ordenadas por ordem\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - Tipo da foto (opcional, default: 'escola')\n * @returns {Promise<Array>} Lista de legendas ordenadas\n */\nexport const getLegendasByEscolaOrdered = async (escolaId, tipoFoto = 'escola') => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('tipo_foto', tipoFoto)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true, nullsFirst: false })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas ordenadas da escola:', error);\n    throw error;\n  }\n};\n\nconst LegendasService = {\n  testLegendasTable,\n  getLegendaByImageUrl,\n  getLegendaByImageUrlFlexivel,\n  getLegendaByImageUrlAnyCategory,\n  addLegendaFoto,\n  updateLegendaFoto,\n  deleteLegendaFoto,\n  getLegendasByEscola,\n  getTituloByVideoUrl,\n  updateImageOrder,\n  updateMultipleImageOrders,\n  getLegendasByEscolaOrdered\n};\n\nexport default LegendasService;\n","import { supabase } from '../supabaseClient';\n\n// Configura√ß√µes para imagens das hist√≥rias do professor\nconst HISTORIA_PROFESSOR_CONFIG = {\n  BUCKET_NAME: 'historia-professor-imagens',\n  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB\n  ALLOWED_TYPES: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'],\n  MAX_IMAGES_PER_HISTORIA: 1,\n  MIN_DIMENSIONS: { width: 200, height: 200 }\n};\n\n/**\n * Valida um arquivo de imagem\n * @param {File} file - Arquivo a ser validado\n * @returns {Object} Resultado da valida√ß√£o\n */\nconst validateImageFile = (file) => {\n  // Verificar tipo MIME\n  if (!HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.includes(file.type)) {\n    return {\n      isValid: false,\n      error: `Tipo de arquivo n√£o suportado. Use apenas: ${HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1].toUpperCase()).join(', ')}`\n    };\n  }\n\n  // Verificar tamanho\n  if (file.size > HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE) {\n    return {\n      isValid: false,\n      error: `Arquivo muito grande. Tamanho m√°ximo: ${HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB`\n    };\n  }\n\n  // Verificar extens√£o\n  const extension = file.name.split('.').pop().toLowerCase();\n  const allowedExtensions = HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1]);\n  if (!allowedExtensions.includes(extension)) {\n    return {\n      isValid: false,\n      error: `Extens√£o n√£o permitida. Use apenas: ${allowedExtensions.join(', ')}`\n    };\n  }\n\n  return { isValid: true };\n};\n\n/**\n * Valida dimens√µes da imagem (opcional)\n * @param {File} file - Arquivo de imagem\n * @returns {Promise<boolean>} Se as dimens√µes s√£o v√°lidas\n */\nconst validateImageDimensions = (file) => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      const isValid = img.width >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.width &&\n                     img.height >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.height;\n      resolve(isValid);\n    };\n    img.onerror = () => resolve(false);\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Gera nome √∫nico para o arquivo\n * @param {File} file - Arquivo\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {string} Nome √∫nico do arquivo\n */\nconst generateUniqueFileName = (file, escolaId, historiaId) => {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  const extension = file.name.split('.').pop().toLowerCase();\n  return `historia_${historiaId}_${timestamp}_${random}.${extension}`;\n};\n\n/**\n * Buscar todas as hist√≥rias do professor de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de hist√≥rias\n */\nexport const getHistoriasProfessor = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Adicionar URLs p√∫blicas das imagens\n    const historiasComImagens = data.map((historia) => {\n      if (historia.imagem_url) {\n        try {\n          const { data: { publicUrl } } = supabase.storage\n            .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n            .getPublicUrl(historia.imagem_url);\n\n          return { ...historia, imagem_public_url: publicUrl };\n        } catch (err) {\n          return { ...historia, imagem_public_url: null, urlError: err.message };\n        }\n      }\n      return historia;\n    });\n\n    return historiasComImagens;\n\n  } catch (error) {\n    console.error('Erro ao buscar hist√≥rias do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Criar nova hist√≥ria do professor\n * @param {Object} historiaData - Dados da hist√≥ria\n * @returns {Promise<Object>} Hist√≥ria criada\n */\nexport const createHistoriaProfessor = async (historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .insert([{\n        escola_id: historiaData.escola_id,\n        nome_professor: historiaData.nome_professor || null,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem || 1,\n        ativo: historiaData.ativo !== false,\n        foto_rosto: historiaData.foto_rosto || null\n      }])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    console.error('Erro ao criar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @param {Object} historiaData - Dados atualizados\n * @returns {Promise<Object>} Hist√≥ria atualizada\n */\nexport const updateHistoriaProfessor = async (historiaId, historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .update({\n        nome_professor: historiaData.nome_professor,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem,\n        ativo: historiaData.ativo,\n        foto_rosto: historiaData.foto_rosto || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    console.error('Erro ao atualizar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessor = async (historiaId) => {\n  try {\n    // Deletar a hist√≥ria\n    const { error: deleteError } = await supabase\n      .from('historias_professor')\n      .delete()\n      .eq('id', historiaId);\n\n    if (deleteError) {\n      throw deleteError;\n    }\n  } catch (error) {\n    console.error('Erro ao deletar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Upload de imagem para uma hist√≥ria do professor\n * @param {File} file - Arquivo de imagem\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da hist√≥ria\n * @param {string} descricao - Descri√ß√£o da imagem\n * @returns {Promise<Object>} Dados da imagem salva\n */\nexport const uploadHistoriaProfessorImage = async (file, escolaId, historiaId, descricao = '') => {\n  try {\n    // Validar arquivo\n    const validation = validateImageFile(file);\n    if (!validation.isValid) {\n      throw new Error(validation.error);\n    }\n\n    // Validar dimens√µes (opcional)\n    const hasValidDimensions = await validateImageDimensions(file);\n    if (!hasValidDimensions) {\n      console.warn('Imagem com dimens√µes menores que o recomendado');\n    }\n\n    // Gerar nome √∫nico\n    const fileName = generateUniqueFileName(file, escolaId, historiaId);\n    const filePath = `${escolaId}/${fileName}`;\n\n    // Upload ao bucket\n    const { error: uploadError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false\n      });\n\n    if (uploadError) {\n      throw new Error(`Erro no upload: ${uploadError.message}`);\n    }\n\n    // Obter URL p√∫blica - n√£o usado\n    // const { data: { publicUrl } } = supabase.storage\n    //   .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n    //   .getPublicUrl(filePath);\n\n    // Atualizar a hist√≥ria com a URL da imagem\n    const { data: historia, error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: descricao.trim() || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (updateError) {\n      // Se falhar ao atualizar, deletar o arquivo\n      await supabase.storage\n        .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n        .remove([filePath]);\n      throw new Error(`Erro ao salvar metadados: ${updateError.message}`);\n    }\n\n    return {\n      id: historia.id,\n      descricao_imagem: historia.descricao_imagem\n    };\n\n  } catch (error) {\n    console.error('Erro no upload da imagem da hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar imagem de uma hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessorImage = async (historiaId) => {\n  try {\n    // Buscar a hist√≥ria para obter a URL da imagem\n    const { data: historia, error: fetchError } = await supabase\n      .from('historias_professor')\n      .select('imagem_url')\n      .eq('id', historiaId)\n      .single();\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!historia.imagem_url) {\n      return; // N√£o h√° imagem para deletar\n    }\n\n    // Atualizar a hist√≥ria removendo a refer√™ncia da imagem\n    const { error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId);\n\n    if (updateError) {\n      throw updateError;\n    }\n\n    // Deletar arquivo do storage\n    const { error: storageError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .remove([historia.imagem_url]);\n\n    if (storageError) {\n      console.warn('Erro ao deletar imagem do storage:', storageError);\n    }\n\n  } catch (error) {\n    console.error('Erro ao deletar imagem da hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes da tabela escolas_completa\n * @returns {Promise<Object>} Resultado da migra√ß√£o\n */\nexport const migrarDadosExistentes = async () => {\n  try {\n    // Buscar escolas com hist√≥ria do professor\n    const { data: escolas, error: fetchError } = await supabase\n      .from('escolas_completa')\n      .select('id, historia_do_prof')\n      .not('historia_do_prof', 'is', null)\n      .neq('historia_do_prof', '');\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!escolas || escolas.length === 0) {\n      return { migradas: 0, mensagem: 'Nenhuma hist√≥ria para migrar' };\n    }\n\n    // Inserir hist√≥rias na nova tabela\n    const historiasParaInserir = escolas.map(escola => ({\n      escola_id: escola.id,\n      historia: escola.historia_do_prof,\n      ordem: 1,\n      ativo: true,\n      created_at: new Date().toISOString()\n    }));\n\n    const { data: historiasInseridas, error: insertError } = await supabase\n      .from('historias_professor')\n      .insert(historiasParaInserir)\n      .select();\n\n    if (insertError) {\n      throw insertError;\n    }\n\n    return {\n      migradas: historiasInseridas.length,\n      mensagem: `${historiasInseridas.length} hist√≥rias migradas com sucesso`\n    };\n\n  } catch (error) {\n    console.error('Erro na migra√ß√£o de dados:', error);\n    throw error;\n  }\n};\n\n/**\n * Verificar se uma escola tem hist√≥rias do professor\n * @param {number} escolaId - ID da escola\n * @returns {Promise<boolean>} Se tem hist√≥rias\n */\nexport const escolaTemHistoriasProfessor = async (escolaId) => {\n  try {\n    const { count, error } = await supabase\n      .from('historias_professor')\n      .select('*', { count: 'exact', head: true })\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (error) {\n      throw error;\n    }\n\n    return (count || 0) > 0;\n\n  } catch (error) {\n    console.error('Erro ao verificar hist√≥rias do professor:', error);\n    return false;\n  }\n}; ","import { supabase } from '../supabaseClient';\n\n// Buscar todos os v√≠deos de uma escola\nexport async function getVideosEscola(escolaId) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .select('*')\n    .eq('escola_id', escolaId)\n    .eq('ativo', true)\n    .order('created_at', { ascending: false });\n  if (error) throw error;\n  return data;\n}\n\n// Criar novo v√≠deo\nexport async function createVideoEscola(video) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .insert([video])\n    .select();\n  if (error) throw error;\n  return data?.[0];\n}\n\n// Atualizar v√≠deo existente\nexport async function updateVideoEscola(id, updates) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .update(updates)\n    .eq('id', id)\n    .select();\n  if (error) throw error;\n  return data?.[0];\n}\n\n// Remover v√≠deo\nexport async function deleteVideoEscola(id) {\n  const { error } = await supabase\n    .from('titulos_videos')\n    .delete()\n    .eq('id', id);\n  if (error) throw error;\n  return true;\n} "],"names":["testLegendasTable","async","error","supabase","from","select","limit","console","warn","message","log","getLegendaByImageUrl","imageUrl","escolaId","options","arguments","length","undefined","query","eq","ativo","categoria","tipo_foto","data","order","ascending","getLegendaByImageUrlFlexivel","preferencias","concat","legenda","data2","error2","data3","error3","nomeArquivo","split","pop","data4","error4","ilike","addLegendaFoto","insert","legendaData","single","updateLegendaFoto","legendaId","updateData","update","getTituloByVideoUrl","videoUrl","code","updateImageOrder","ordem","updated_at","Date","toISOString","id","legendaPadrao","replace","escola_id","imagem_url","created_at","updateMultipleImageOrders","imageOrders","Promise","all","map","_ref","HISTORIA_PROFESSOR_CONFIG","BUCKET_NAME","MAX_FILE_SIZE","ALLOWED_TYPES","MAX_IMAGES_PER_HISTORIA","MIN_DIMENSIONS","width","height","getHistoriasProfessor","historia","publicUrl","storage","getPublicUrl","_objectSpread","imagem_public_url","err","urlError","createHistoriaProfessor","historiaData","nome_professor","foto_rosto","updateHistoriaProfessor","historiaId","deleteHistoriaProfessor","deleteError","delete","getVideosEscola","createVideoEscola","video","updateVideoEscola","updates","deleteVideoEscola"],"sourceRoot":""}