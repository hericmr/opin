{"version":3,"file":"static/js/312.d54d39ef.chunk.js","mappings":"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","sources":["utils/dateUtils.js","services/legendasService.js","components/AdminPanel/constants/cardVisibilityConfig.js","services/historiaProfessorService.js","services/videoService.js","services/globalConfigService.js","hooks/useGlobalCardVisibility.js"],"sourcesContent":["/**\n * Utility functions for date formatting\n */\n\n/**\n * Converte uma data do formato ISO (YYYY-MM-DD) para formato brasileiro (DD/MM/YYYY)\n * @param {string} isoDate - Data no formato ISO (YYYY-MM-DD)\n * @returns {string} Data no formato brasileiro (DD/MM/YYYY) ou string vazia se inv√°lida\n */\nexport const formatDateToBrazilian = (isoDate) => {\n  if (!isoDate || isoDate === '') return '';\n  \n  try {\n    // Se j√° est√° no formato brasileiro, retorna como est√°\n    if (isoDate.includes('/') && isoDate.length === 10) {\n      return isoDate;\n    }\n    \n    // Tenta parsear como ISO (YYYY-MM-DD)\n    const date = new Date(isoDate + 'T00:00:00');\n    if (isNaN(date.getTime())) return '';\n    \n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    \n    return `${day}/${month}/${year}`;\n  } catch (e) {\n    return '';\n  }\n};\n\n/**\n * Converte uma data do formato brasileiro (DD/MM/YYYY) para formato ISO (YYYY-MM-DD)\n * @param {string} brazilianDate - Data no formato brasileiro (DD/MM/YYYY)\n * @returns {string} Data no formato ISO (YYYY-MM-DD) ou string vazia se inv√°lida\n */\nexport const formatDateToISO = (brazilianDate) => {\n  if (!brazilianDate || brazilianDate === '') return '';\n  \n  // Se j√° est√° no formato ISO, retorna como est√°\n  if (brazilianDate.includes('-') && brazilianDate.length === 10) {\n    return brazilianDate;\n  }\n  \n  // Remove caracteres n√£o num√©ricos exceto barras\n  const cleaned = brazilianDate.replace(/[^\\d/]/g, '');\n  \n  // Se n√£o tem barras, tenta formatar automaticamente\n  if (!cleaned.includes('/')) {\n    const digits = cleaned.replace(/\\D/g, '');\n    if (digits.length === 8) {\n      const day = digits.substring(0, 2);\n      const month = digits.substring(2, 4);\n      const year = digits.substring(4, 8);\n      const formatted = `${day}/${month}/${year}`;\n      return formatBrazilianToIso(formatted);\n    }\n    return '';\n  }\n  \n  return formatBrazilianToIso(cleaned);\n};\n\n/**\n * Fun√ß√£o auxiliar para converter formato brasileiro para ISO\n */\nconst formatBrazilianToIso = (brazilianDate) => {\n  const parts = brazilianDate.split('/');\n  if (parts.length !== 3) return '';\n  \n  const day = parts[0].padStart(2, '0');\n  const month = parts[1].padStart(2, '0');\n  const year = parts[2];\n  \n  // Valida√ß√£o b√°sica\n  if (day.length !== 2 || month.length !== 2 || year.length !== 4) return '';\n  if (parseInt(month) < 1 || parseInt(month) > 12) return '';\n  if (parseInt(day) < 1 || parseInt(day) > 31) return '';\n  \n  // Valida√ß√£o de data v√°lida\n  const date = new Date(`${year}-${month}-${day}T00:00:00`);\n  if (isNaN(date.getTime())) return '';\n  if (date.getDate() !== parseInt(day) || date.getMonth() + 1 !== parseInt(month)) return '';\n  \n  return `${year}-${month}-${day}`;\n};\n\n/**\n * Formata uma data para exibi√ß√£o no formato brasileiro usando toLocaleDateString\n * @param {string|Date} date - Data em formato ISO ou objeto Date\n * @returns {string} Data formatada no formato brasileiro (DD/MM/YYYY)\n */\nexport const formatDateForDisplay = (date) => {\n  if (!date) return '';\n  \n  try {\n    // Se j√° √© um objeto Date\n    if (date instanceof Date) {\n      return date.toLocaleDateString('pt-BR');\n    }\n    \n    // Se √© uma string ISO (YYYY-MM-DD)\n    if (typeof date === 'string') {\n      // Tenta parsear como ISO\n      const dateObj = new Date(date + 'T00:00:00');\n      if (!isNaN(dateObj.getTime())) {\n        return dateObj.toLocaleDateString('pt-BR');\n      }\n      \n      // Se j√° est√° no formato brasileiro, retorna como est√°\n      if (date.includes('/') && date.length === 10) {\n        return date;\n      }\n    }\n    \n    return '';\n  } catch (e) {\n    return '';\n  }\n};\n\n","import { supabase } from '../supabaseClient';\nimport logger from '../utils/logger';\n\n/**\n * Servi√ßo para gerenciar legendas de fotos\n */\n\n/**\n * Testar se a tabela legendas_fotos existe e est√° acess√≠vel\n * @returns {Promise<boolean>} True se a tabela existe\n */\nexport const testLegendasTable = async () => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .select('count')\n      .limit(1);\n    \n    if (error) {\n      logger.warn('Tabela legendas_fotos n√£o encontrada ou sem permiss√£o:', error.message);\n      return false;\n    }\n    \n    logger.debug('Tabela legendas_fotos acess√≠vel');\n    return true;\n  } catch (error) {\n    logger.warn('Erro ao testar tabela legendas_fotos:', error.message);\n    return false;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (todos os atributos opcionais)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} options - Op√ß√µes de busca (todos opcionais)\n * @param {string} options.categoria - Categoria da imagem\n * @param {string} options.tipo_foto - Tipo da foto\n * @param {boolean} options.ativo - Se deve buscar apenas ativas\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imageUrl, escolaId, options = {}) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId);\n\n    // Aplicar filtros opcionais\n    if (options.ativo !== false) { // Por padr√£o, busca apenas ativas\n      query = query.eq('ativo', true);\n    }\n    \n    if (options.categoria) {\n      query = query.eq('categoria', options.categoria);\n    }\n    \n    if (options.tipo_foto) {\n      query = query.eq('tipo_foto', options.tipo_foto);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      logger.warn('Erro ao buscar legenda:', error.message);\n      return null;\n    }\n\n    // Retorna a primeira legenda encontrada (mais recente)\n    return data && data.length > 0 ? data[0] : null;\n  } catch (error) {\n    logger.warn('Erro ao buscar legenda:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (busca flex√≠vel com m√∫ltiplas estrat√©gias)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} preferencias - Prefer√™ncias de busca (todos opcionais)\n * @param {string} preferencias.categoria - Categoria preferida\n * @param {string} preferencias.tipo_foto - Tipo de foto preferido\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlFlexivel = async (imageUrl, escolaId, preferencias = {}) => {\n  try {\n    logger.debug(`üîç Buscando legenda flex√≠vel para: ${imageUrl} (escola: ${escolaId})`);\n    \n    // Estrat√©gia 1: Busca com prefer√™ncias espec√≠ficas\n    if (preferencias.categoria || preferencias.tipo_foto) {\n      logger.debug('  üìã Tentativa 1: Busca com prefer√™ncias espec√≠ficas');\n      const legenda = await getLegendaByImageUrl(imageUrl, escolaId, preferencias);\n      if (legenda) {\n        logger.debug('  ‚úÖ Encontrada com prefer√™ncias espec√≠ficas');\n        return legenda;\n      }\n    }\n\n    // Estrat√©gia 2: Busca apenas por URL e escola (sem outros filtros)\n    logger.debug('  üìã Tentativa 2: Busca apenas por URL e escola');\n    const { data: data2, error: error2 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error2) {\n      logger.warn('  ‚ùå Erro na busca por URL e escola:', error2.message);\n    } else if (data2 && data2.length > 0) {\n      logger.debug('  ‚úÖ Encontrada por URL e escola');\n      return data2[0];\n    }\n\n    // Estrat√©gia 3: Busca incluindo legendas inativas\n    logger.debug('  üìã Tentativa 3: Busca incluindo legendas inativas');\n    const { data: data3, error: error3 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .order('created_at', { ascending: false });\n\n    if (error3) {\n      logger.warn('  ‚ùå Erro na busca incluindo inativas:', error3.message);\n    } else if (data3 && data3.length > 0) {\n      logger.debug('  ‚úÖ Encontrada incluindo legendas inativas');\n      return data3[0];\n    }\n\n    // Estrat√©gia 4: Busca por nome do arquivo (sem caminho completo)\n    const nomeArquivo = imageUrl.split('/').pop();\n    logger.debug(`  üìã Tentativa 4: Busca por nome do arquivo: ${nomeArquivo}`);\n    const { data: data4, error: error4 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .ilike('imagem_url', `%${nomeArquivo}`)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error4) {\n      logger.warn('  ‚ùå Erro na busca por nome do arquivo:', error4.message);\n    } else if (data4 && data4.length > 0) {\n      logger.debug('  ‚úÖ Encontrada por nome do arquivo');\n      return data4[0];\n    }\n\n    logger.debug('  ‚ùå Nenhuma legenda encontrada com todas as estrat√©gias');\n    return null;\n\n  } catch (error) {\n    logger.warn('Erro ao buscar legenda flex√≠vel:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (sem filtro de categoria) - MANTIDA PARA COMPATIBILIDADE\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlAnyCategory = async (imageUrl, escolaId) => {\n  return getLegendaByImageUrlFlexivel(imageUrl, escolaId);\n};\n\n/**\n * Adicionar nova legenda de foto\n * @param {Object} legendaData - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legendaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    logger.error('Erro ao adicionar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto existente\n * @param {number} legendaId - ID da legenda\n * @param {Object} updateData - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (legendaId, updateData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(updateData)\n      .eq('id', legendaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    logger.error('Erro ao atualizar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto\n * @param {number} legendaId - ID da legenda\n * @returns {Promise<boolean>} True se deletado com sucesso\n */\nexport const deleteLegendaFoto = async (legendaId) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .delete()\n      .eq('id', legendaId);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    logger.error('Erro ao deletar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} categoria - Categoria das imagens (opcional)\n * @returns {Promise<Array>} Lista de legendas\n */\nexport const getLegendasByEscola = async (escolaId, categoria = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId);\n\n    if (categoria) {\n      query = query.eq('categoria', categoria);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    logger.error('Erro ao buscar legendas da escola:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar t√≠tulo personalizado de v√≠deo por URL\n * @param {string} videoUrl - URL do v√≠deo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} T√≠tulo encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('categoria', 'video')\n      .single();\n\n    if (error) {\n      // Se n√£o encontrar, retorna null (n√£o √© erro)\n      if (error.code === 'PGRST116') {\n        return null;\n      }\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    logger.warn('Erro ao buscar t√≠tulo do v√≠deo:', error.message);\n    return null;\n  }\n};\n\n/**\n * Atualizar ordem de uma imagem\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {number} ordem - Nova ordem\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateImageOrder = async (imageUrl, escolaId, ordem) => {\n  try {\n    // Primeiro, buscar a legenda existente\n    const legenda = await getLegendaByImageUrl(imageUrl, escolaId, { ativo: false });\n    \n    if (legenda) {\n      // Se existe, atualizar apenas a ordem\n      const { data, error } = await supabase\n        .from('legendas_fotos')\n        .update({ ordem, updated_at: new Date().toISOString() })\n        .eq('id', legenda.id)\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } else {\n      // Se n√£o existe, criar uma entrada b√°sica com ordem\n      // Extrair nome do arquivo para usar como legenda padr√£o\n      const fileName = imageUrl.split('/').pop() || 'Imagem';\n      const legendaPadrao = fileName.replace(/\\.[^/.]+$/, '').replace(/[_-]/g, ' ') || 'Imagem';\n      \n      const { data, error } = await supabase\n        .from('legendas_fotos')\n        .insert([{\n          escola_id: escolaId,\n          imagem_url: imageUrl,\n          legenda: legendaPadrao, // Valor padr√£o obrigat√≥rio\n          ordem,\n          ativo: true,\n          tipo_foto: 'escola',\n          categoria: 'geral',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        }])\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    }\n  } catch (error) {\n    logger.error('Erro ao atualizar ordem da imagem:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar ordem de m√∫ltiplas imagens\n * @param {Array} imageOrders - Array de objetos { imageUrl, ordem }\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Legendas atualizadas\n */\nexport const updateMultipleImageOrders = async (imageOrders, escolaId) => {\n  try {\n    const updates = await Promise.all(\n      imageOrders.map(({ imageUrl, ordem }) => \n        updateImageOrder(imageUrl, escolaId, ordem)\n      )\n    );\n    return updates;\n  } catch (error) {\n    logger.error('Erro ao atualizar ordens das imagens:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola ordenadas por ordem\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - Tipo da foto (opcional, default: 'escola')\n * @returns {Promise<Array>} Lista de legendas ordenadas\n */\nexport const getLegendasByEscolaOrdered = async (escolaId, tipoFoto = 'escola') => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('tipo_foto', tipoFoto)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true, nullsFirst: false })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    logger.error('Erro ao buscar legendas ordenadas da escola:', error);\n    throw error;\n  }\n};\n\nconst LegendasService = {\n  testLegendasTable,\n  getLegendaByImageUrl,\n  getLegendaByImageUrlFlexivel,\n  getLegendaByImageUrlAnyCategory,\n  addLegendaFoto,\n  updateLegendaFoto,\n  deleteLegendaFoto,\n  getLegendasByEscola,\n  getTituloByVideoUrl,\n  updateImageOrder,\n  updateMultipleImageOrders,\n  getLegendasByEscolaOrdered\n};\n\nexport default LegendasService;\n","// Configura√ß√£o dos cards dispon√≠veis para controle de visibilidade\nexport const CARD_VISIBILITY_CONFIG = [\n  {\n    id: 'basicInfo',\n    label: 'Informa√ß√µes B√°sicas',\n    description: 'Nome, munic√≠pio, endere√ßo, terra ind√≠gena',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'modalidades',\n    label: 'Modalidades de Ensino',\n    description: 'Modalidades e turnos de funcionamento',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'infraestrutura',\n    label: 'Infraestrutura',\n    description: 'Estrutura f√≠sica, √°gua, internet, equipamentos',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'gestaoProfessores',\n    label: 'Equipe',\n    description: 'Dire√ß√£o, professores, forma√ß√£o profissional',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'projetosParcerias',\n    label: 'Projetos e Parcerias',\n    description: 'Projetos, parcerias, ONGs, desejos da comunidade',\n    defaultVisible: true,\n    category: 'grid'\n  },\n  {\n    id: 'historiaEscola',\n    label: 'Hist√≥ria da Escola',\n    description: 'Hist√≥ria e contexto da escola',\n    defaultVisible: true,\n    category: 'standalone'\n  },\n  {\n    id: 'imagensEscola',\n    label: 'Imagens da Escola',\n    description: 'Galeria de fotos da escola',\n    defaultVisible: true,\n    category: 'standalone'\n  },\n  {\n    id: 'historiaProfessor',\n    label: 'Hist√≥ria dos Professores',\n    description: 'Depoimentos e hist√≥rias dos professores',\n    defaultVisible: true,\n    category: 'standalone'\n  },\n  {\n    id: 'documentos',\n    label: 'Documentos',\n    description: 'PDFs e documentos da escola',\n    defaultVisible: true,\n    category: 'standalone'\n  },\n  {\n    id: 'videos',\n    label: 'V√≠deos',\n    description: 'V√≠deos e produ√ß√µes audiovisuais',\n    defaultVisible: true,\n    category: 'standalone'\n  }\n];\n\n// Fun√ß√£o helper para obter visibilidade padr√£o\nexport const getDefaultVisibility = () => {\n  return CARD_VISIBILITY_CONFIG.reduce((acc, card) => {\n    acc[card.id] = card.defaultVisible;\n    return acc;\n  }, {});\n};\n\n// Fun√ß√£o helper para obter visibilidade de um card espec√≠fico\n// Considera primeiro a configura√ß√£o individual da escola, depois a global\nexport const isCardVisible = (cardsVisibilidade, cardId, globalVisibility = null) => {\n  // Se a escola tem configura√ß√£o individual para este card, usa ela\n  if (cardsVisibilidade && cardsVisibilidade.hasOwnProperty(cardId)) {\n    return cardsVisibilidade[cardId] !== false;\n  }\n  \n  // Se n√£o tem configura√ß√£o individual, usa a global\n  if (globalVisibility && globalVisibility.hasOwnProperty(cardId)) {\n    return globalVisibility[cardId] !== false;\n  }\n  \n  // Default: vis√≠vel\n  return true;\n};\n\n","import { supabase } from '../supabaseClient';\nimport logger from '../utils/logger';\n\n// Configura√ß√µes para imagens das hist√≥rias do professor\nconst HISTORIA_PROFESSOR_CONFIG = {\n  BUCKET_NAME: 'historia-professor-imagens',\n  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB\n  ALLOWED_TYPES: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'],\n  MAX_IMAGES_PER_HISTORIA: 1,\n  MIN_DIMENSIONS: { width: 200, height: 200 }\n};\n\n/**\n * Valida um arquivo de imagem\n * @param {File} file - Arquivo a ser validado\n * @returns {Object} Resultado da valida√ß√£o\n */\nconst validateImageFile = (file) => {\n  // Verificar tipo MIME\n  if (!HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.includes(file.type)) {\n    return {\n      isValid: false,\n      error: `Tipo de arquivo n√£o suportado. Use apenas: ${HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1].toUpperCase()).join(', ')}`\n    };\n  }\n\n  // Verificar tamanho\n  if (file.size > HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE) {\n    return {\n      isValid: false,\n      error: `Arquivo muito grande. Tamanho m√°ximo: ${HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB`\n    };\n  }\n\n  // Verificar extens√£o\n  const extension = file.name.split('.').pop().toLowerCase();\n  const allowedExtensions = HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1]);\n  if (!allowedExtensions.includes(extension)) {\n    return {\n      isValid: false,\n      error: `Extens√£o n√£o permitida. Use apenas: ${allowedExtensions.join(', ')}`\n    };\n  }\n\n  return { isValid: true };\n};\n\n/**\n * Valida dimens√µes da imagem (opcional)\n * @param {File} file - Arquivo de imagem\n * @returns {Promise<boolean>} Se as dimens√µes s√£o v√°lidas\n */\nconst validateImageDimensions = (file) => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      const isValid = img.width >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.width &&\n                     img.height >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.height;\n      resolve(isValid);\n    };\n    img.onerror = () => resolve(false);\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Gera nome √∫nico para o arquivo\n * @param {File} file - Arquivo\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {string} Nome √∫nico do arquivo\n */\nconst generateUniqueFileName = (file, escolaId, historiaId) => {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  const extension = file.name.split('.').pop().toLowerCase();\n  return `historia_${historiaId}_${timestamp}_${random}.${extension}`;\n};\n\n/**\n * Buscar todas as hist√≥rias do professor de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de hist√≥rias\n */\nexport const getHistoriasProfessor = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Adicionar URLs p√∫blicas das imagens\n    const historiasComImagens = data.map((historia) => {\n      if (historia.imagem_url) {\n        try {\n          const { data: { publicUrl } } = supabase.storage\n            .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n            .getPublicUrl(historia.imagem_url);\n\n          return { ...historia, imagem_public_url: publicUrl };\n        } catch (err) {\n          return { ...historia, imagem_public_url: null, urlError: err.message };\n        }\n      }\n      return historia;\n    });\n\n    return historiasComImagens;\n\n  } catch (error) {\n    logger.error('Erro ao buscar hist√≥rias do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Criar nova hist√≥ria do professor\n * @param {Object} historiaData - Dados da hist√≥ria\n * @returns {Promise<Object>} Hist√≥ria criada\n */\nexport const createHistoriaProfessor = async (historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .insert([{\n        escola_id: historiaData.escola_id,\n        nome_professor: historiaData.nome_professor || null,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem || 1,\n        ativo: historiaData.ativo !== false,\n        foto_rosto: historiaData.foto_rosto || null\n      }])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    logger.error('Erro ao criar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @param {Object} historiaData - Dados atualizados\n * @returns {Promise<Object>} Hist√≥ria atualizada\n */\nexport const updateHistoriaProfessor = async (historiaId, historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .update({\n        nome_professor: historiaData.nome_professor,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem,\n        ativo: historiaData.ativo,\n        foto_rosto: historiaData.foto_rosto || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    logger.error('Erro ao atualizar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessor = async (historiaId) => {\n  try {\n    // Deletar a hist√≥ria\n    const { error: deleteError } = await supabase\n      .from('historias_professor')\n      .delete()\n      .eq('id', historiaId);\n\n    if (deleteError) {\n      throw deleteError;\n    }\n  } catch (error) {\n    logger.error('Erro ao deletar hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Upload de imagem para uma hist√≥ria do professor\n * @param {File} file - Arquivo de imagem\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da hist√≥ria\n * @param {string} descricao - Descri√ß√£o da imagem\n * @returns {Promise<Object>} Dados da imagem salva\n */\nexport const uploadHistoriaProfessorImage = async (file, escolaId, historiaId, descricao = '') => {\n  try {\n    // Validar arquivo\n    const validation = validateImageFile(file);\n    if (!validation.isValid) {\n      throw new Error(validation.error);\n    }\n\n    // Validar dimens√µes (opcional)\n    const hasValidDimensions = await validateImageDimensions(file);\n    if (!hasValidDimensions) {\n      logger.warn('Imagem com dimens√µes menores que o recomendado');\n    }\n\n    // Gerar nome √∫nico\n    const fileName = generateUniqueFileName(file, escolaId, historiaId);\n    const filePath = `${escolaId}/${fileName}`;\n\n    // Upload ao bucket\n    const { error: uploadError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false\n      });\n\n    if (uploadError) {\n      throw new Error(`Erro no upload: ${uploadError.message}`);\n    }\n\n    // Obter URL p√∫blica - n√£o usado\n    // const { data: { publicUrl } } = supabase.storage\n    //   .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n    //   .getPublicUrl(filePath);\n\n    // Atualizar a hist√≥ria com a URL da imagem\n    const { data: historia, error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: descricao.trim() || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (updateError) {\n      // Se falhar ao atualizar, deletar o arquivo\n      await supabase.storage\n        .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n        .remove([filePath]);\n      throw new Error(`Erro ao salvar metadados: ${updateError.message}`);\n    }\n\n    return {\n      id: historia.id,\n      descricao_imagem: historia.descricao_imagem\n    };\n\n  } catch (error) {\n    logger.error('Erro no upload da imagem da hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar imagem de uma hist√≥ria do professor\n * @param {number} historiaId - ID da hist√≥ria\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessorImage = async (historiaId) => {\n  try {\n    // Buscar a hist√≥ria para obter a URL da imagem\n    const { data: historia, error: fetchError } = await supabase\n      .from('historias_professor')\n      .select('imagem_url')\n      .eq('id', historiaId)\n      .single();\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!historia.imagem_url) {\n      return; // N√£o h√° imagem para deletar\n    }\n\n    // Atualizar a hist√≥ria removendo a refer√™ncia da imagem\n    const { error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId);\n\n    if (updateError) {\n      throw updateError;\n    }\n\n    // Deletar arquivo do storage\n    const { error: storageError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .remove([historia.imagem_url]);\n\n    if (storageError) {\n      logger.warn('Erro ao deletar imagem do storage:', storageError);\n    }\n\n  } catch (error) {\n    logger.error('Erro ao deletar imagem da hist√≥ria do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes da tabela escolas_completa\n * @returns {Promise<Object>} Resultado da migra√ß√£o\n */\nexport const migrarDadosExistentes = async () => {\n  try {\n    // Buscar escolas com hist√≥ria do professor\n    const { data: escolas, error: fetchError } = await supabase\n      .from('escolas_completa')\n      .select('id, historia_do_prof')\n      .not('historia_do_prof', 'is', null)\n      .neq('historia_do_prof', '');\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!escolas || escolas.length === 0) {\n      return { migradas: 0, mensagem: 'Nenhuma hist√≥ria para migrar' };\n    }\n\n    // Inserir hist√≥rias na nova tabela\n    const historiasParaInserir = escolas.map(escola => ({\n      escola_id: escola.id,\n      historia: escola.historia_do_prof,\n      ordem: 1,\n      ativo: true,\n      created_at: new Date().toISOString()\n    }));\n\n    const { data: historiasInseridas, error: insertError } = await supabase\n      .from('historias_professor')\n      .insert(historiasParaInserir)\n      .select();\n\n    if (insertError) {\n      throw insertError;\n    }\n\n    return {\n      migradas: historiasInseridas.length,\n      mensagem: `${historiasInseridas.length} hist√≥rias migradas com sucesso`\n    };\n\n  } catch (error) {\n    logger.error('Erro na migra√ß√£o de dados:', error);\n    throw error;\n  }\n};\n\n/**\n * Verificar se uma escola tem hist√≥rias do professor\n * @param {number} escolaId - ID da escola\n * @returns {Promise<boolean>} Se tem hist√≥rias\n */\nexport const escolaTemHistoriasProfessor = async (escolaId) => {\n  try {\n    const { count, error } = await supabase\n      .from('historias_professor')\n      .select('*', { count: 'exact', head: true })\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (error) {\n      throw error;\n    }\n\n    return (count || 0) > 0;\n\n  } catch (error) {\n    logger.error('Erro ao verificar hist√≥rias do professor:', error);\n    return false;\n  }\n}; ","import { supabase } from '../supabaseClient';\n\n// Buscar todos os v√≠deos de uma escola\nexport async function getVideosEscola(escolaId) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .select('*')\n    .eq('escola_id', escolaId)\n    .eq('ativo', true)\n    .order('created_at', { ascending: false });\n  if (error) throw error;\n  return data;\n}\n\n// Criar novo v√≠deo\nexport async function createVideoEscola(video) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .insert([video])\n    .select();\n  if (error) throw error;\n  return data?.[0];\n}\n\n// Atualizar v√≠deo existente\nexport async function updateVideoEscola(id, updates) {\n  const { data, error } = await supabase\n    .from('titulos_videos')\n    .update(updates)\n    .eq('id', id)\n    .select();\n  if (error) throw error;\n  return data?.[0];\n}\n\n// Remover v√≠deo\nexport async function deleteVideoEscola(id) {\n  const { error } = await supabase\n    .from('titulos_videos')\n    .delete()\n    .eq('id', id);\n  if (error) throw error;\n  return true;\n} ","import { supabase } from '../supabaseClient';\nimport logger from '../utils/logger';\n\n/**\n * Servi√ßo para gerenciar configura√ß√µes globais do sistema\n */\nexport class GlobalConfigService {\n  /**\n   * Obter configura√ß√£o global de visibilidade de cards\n   * @returns {Promise<Object|null>} Configura√ß√£o de visibilidade ou null se n√£o encontrada\n   */\n  static async getGlobalCardsVisibility() {\n    try {\n      const { data, error } = await supabase\n        .from('configuracao_global')\n        .select('valor')\n        .eq('chave', 'cards_visibilidade_global')\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          // N√£o encontrado - retornar null para usar padr√µes\n          return null;\n        }\n        throw error;\n      }\n\n      return data?.valor || null;\n    } catch (error) {\n      logger.error('Erro ao buscar configura√ß√£o global de visibilidade:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Salvar configura√ß√£o global de visibilidade de cards\n   * @param {Object} visibilityConfig - Configura√ß√£o de visibilidade\n   * @returns {Promise<Object>} Resultado da opera√ß√£o\n   */\n  static async saveGlobalCardsVisibility(visibilityConfig) {\n    try {\n      const { data, error } = await supabase\n        .from('configuracao_global')\n        .upsert({\n          chave: 'cards_visibilidade_global',\n          valor: visibilityConfig,\n          descricao: 'Configura√ß√£o padr√£o de visibilidade de cards para todas as escolas',\n          updated_at: new Date().toISOString()\n        }, {\n          onConflict: 'chave'\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        data: data\n      };\n    } catch (error) {\n      logger.error('Erro ao salvar configura√ß√£o global de visibilidade:', error);\n      return {\n        success: false,\n        error: error.message || 'Erro ao salvar configura√ß√£o global'\n      };\n    }\n  }\n}\n\n","import { useState, useEffect } from 'react';\nimport { GlobalConfigService } from '../services/globalConfigService';\n\n/**\n * Hook para buscar e gerenciar a configura√ß√£o global de visibilidade de cards\n * @returns {Object} { globalVisibility, loading }\n */\nexport const useGlobalCardVisibility = () => {\n  const [globalVisibility, setGlobalVisibility] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const loadGlobalConfig = async () => {\n      try {\n        setLoading(true);\n        const config = await GlobalConfigService.getGlobalCardsVisibility();\n        setGlobalVisibility(config);\n      } catch (error) {\n        console.error('Erro ao carregar configura√ß√£o global:', error);\n        setGlobalVisibility(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadGlobalConfig();\n  }, []);\n\n  return { globalVisibility, loading };\n};\n\n\n\n\n\n\n\n"],"names":["formatDateToBrazilian","isoDate","includes","length","date","Date","isNaN","getTime","day","String","getDate","padStart","month","getMonth","year","getFullYear","concat","e","formatDateToISO","brazilianDate","cleaned","replace","digits","substring","formatted","formatBrazilianToIso","parts","split","parseInt","formatDateForDisplay","toLocaleDateString","dateObj","testLegendasTable","async","error","supabase","from","select","limit","logger","warn","message","debug","getLegendaByImageUrl","imageUrl","escolaId","options","arguments","undefined","query","eq","ativo","categoria","tipo_foto","data","order","ascending","getLegendaByImageUrlFlexivel","preferencias","legenda","data2","error2","data3","error3","nomeArquivo","pop","data4","error4","ilike","addLegendaFoto","insert","legendaData","single","updateLegendaFoto","legendaId","updateData","update","getTituloByVideoUrl","videoUrl","code","updateImageOrder","ordem","updated_at","toISOString","id","legendaPadrao","escola_id","imagem_url","created_at","updateMultipleImageOrders","imageOrders","Promise","all","map","_ref","CARD_VISIBILITY_CONFIG","label","description","defaultVisible","category","getDefaultVisibility","reduce","acc","card","isCardVisible","cardsVisibilidade","cardId","globalVisibility","hasOwnProperty","HISTORIA_PROFESSOR_CONFIG","BUCKET_NAME","MAX_FILE_SIZE","ALLOWED_TYPES","MAX_IMAGES_PER_HISTORIA","MIN_DIMENSIONS","width","height","getHistoriasProfessor","historia","publicUrl","storage","getPublicUrl","_objectSpread","imagem_public_url","err","urlError","createHistoriaProfessor","historiaData","nome_professor","foto_rosto","updateHistoriaProfessor","historiaId","deleteHistoriaProfessor","deleteError","delete","getVideosEscola","createVideoEscola","video","updateVideoEscola","updates","deleteVideoEscola","GlobalConfigService","getGlobalCardsVisibility","valor","saveGlobalCardsVisibility","visibilityConfig","upsert","chave","descricao","onConflict","success","useGlobalCardVisibility","setGlobalVisibility","useState","loading","setLoading","useEffect","config","console","loadGlobalConfig"],"sourceRoot":""}