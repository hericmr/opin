{"version":3,"file":"static/js/14.acae6f63.chunk.js","mappings":"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","sources":["services/legendasService.js","services/historiaProfessorService.js","components/PainelInformacoes/components/DocumentViewer.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\n\n/**\n * Buscar legendas de fotos de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor' (opcional, busca todas se não especificado)\n * @returns {Promise<Array>} Lista de legendas de fotos\n */\nexport const getLegendasFotos = async (escolaId, tipoFoto = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    // Verificar se a coluna tipo_foto existe antes de usá-la\n    if (tipoFoto) {\n      try {\n        query = query.eq('tipo_foto', tipoFoto);\n      } catch (columnError) {\n        // Se a coluna não existe, ignorar o filtro por tipo\n        console.warn('Coluna tipo_foto não encontrada. Ignorando filtro por tipo.');\n      }\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas de fotos:', error);\n    throw error;\n  }\n};\n\n/**\n * Adicionar legenda de foto\n * @param {Object} legenda - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legenda) => {\n  try {\n    console.log('=== DEBUG: addLegendaFoto ===');\n    console.log('Dados recebidos:', legenda);\n    \n    // Remover tipo_foto se a coluna não existir no banco\n    const legendaData = { ...legenda };\n    console.log('Dados iniciais:', legendaData);\n    \n    // Verificar se a coluna tipo_foto existe antes de incluí-la\n    try {\n      console.log('Verificando se a coluna tipo_foto existe...');\n      // Tentar uma consulta simples para verificar se a coluna existe\n      const { data: testData, error: testError } = await supabase\n        .from('legendas_fotos')\n        .select('tipo_foto')\n        .limit(1);\n      \n      console.log('Teste da coluna tipo_foto:', { testData, testError });\n      \n      if (testError && testError.code === '42703') {\n        // Se a coluna não existe, remover do objeto\n        console.warn('Coluna tipo_foto não encontrada. Removendo do objeto de inserção.');\n        delete legendaData.tipo_foto;\n      }\n    } catch (columnError) {\n      // Se a coluna não existe, remover do objeto\n      console.warn('Coluna tipo_foto não encontrada. Removendo do objeto de inserção.');\n      delete legendaData.tipo_foto;\n    }\n\n    console.log('Dados finais para inserção:', legendaData);\n    \n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    console.log('Resposta do Supabase:', { data, error });\n\n    if (error) {\n      console.error('Erro do Supabase:', error);\n      throw error;\n    }\n\n    console.log('Legenda criada com sucesso:', data);\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto\n * @param {number} id - ID da legenda\n * @param {Object} updates - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (id, updates) => {\n  try {\n    console.log('=== DEBUG: updateLegendaFoto ===');\n    console.log('ID da legenda:', id);\n    console.log('Dados para atualização:', updates);\n    \n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    console.log('Resposta do Supabase:', { data, error });\n\n    if (error) {\n      console.error('Erro do Supabase ao atualizar:', error);\n      throw error;\n    }\n\n    console.log('Legenda atualizada com sucesso:', data);\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto (soft delete)\n * @param {number} id - ID da legenda\n * @returns {Promise<boolean>} Sucesso da operação\n */\nexport const deleteLegendaFoto = async (id) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .update({ ativo: false })\n      .eq('id', id);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar títulos de vídeos de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de títulos de vídeos\n */\nexport const getTitulosVideos = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar títulos de vídeos:', error);\n    throw error;\n  }\n};\n\n/**\n * Adicionar título de vídeo\n * @param {Object} titulo - Dados do título\n * @returns {Promise<Object>} Título criado\n */\nexport const addTituloVideo = async (titulo) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .insert([titulo])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar título de vídeo\n * @param {number} id - ID do título\n * @param {Object} updates - Dados para atualizar\n * @returns {Promise<Object>} Título atualizado\n */\nexport const updateTituloVideo = async (id, updates) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar título de vídeo (soft delete)\n * @param {number} id - ID do título\n * @returns {Promise<boolean>} Sucesso da operação\n */\nexport const deleteTituloVideo = async (id) => {\n  try {\n    const { error } = await supabase\n      .from('titulos_videos')\n      .update({ ativo: false })\n      .eq('id', id);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar legenda de foto por URL da imagem\n * @param {string} imagemUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor' (opcional)\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imagemUrl, escolaId, tipoFoto = null) => {\n  try {\n    console.log('getLegendaByImageUrl chamada com:', { imagemUrl, escolaId, tipoFoto });\n    \n    // 1. Tenta buscar por igualdade exata\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imagemUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (tipoFoto) {\n      try {\n        query = query.eq('tipo_foto', tipoFoto);\n      } catch (columnError) {\n        console.warn('Coluna tipo_foto não encontrada. Ignorando filtro por tipo.');\n      }\n    }\n\n    let { data, error } = await query.single();\n    console.log('Busca exata resultou em:', { data, error });\n\n    // Se não encontrou, tenta buscar por finalização\n    if ((error && error.code === 'PGRST116') || !data) {\n      console.log('Tentando busca por finalização...');\n      // Busca por finalização (ilike)\n      const caminhoRelativo = imagemUrl.split('/').slice(-2).join('/'); // ex: 20/2.png\n      console.log('Caminho relativo extraído:', caminhoRelativo);\n      \n      let query2 = supabase\n        .from('legendas_fotos')\n        .select('*')\n        .ilike('imagem_url', `%/${caminhoRelativo}`)\n        .eq('escola_id', escolaId)\n        .eq('ativo', true);\n\n      if (tipoFoto) {\n        try {\n          query2 = query2.eq('tipo_foto', tipoFoto);\n        } catch (columnError) {\n          // Se a coluna não existe, ignora\n        }\n      }\n\n      const { data: data2, error: error2 } = await query2.single();\n      console.log('Busca por finalização resultou em:', { data2, error2 });\n      \n      if (!error2 && data2) {\n        return data2;\n      }\n    }\n\n    if (error && error.code !== 'PGRST116') {\n      throw error;\n    }\n\n    return data || null;\n  } catch (error) {\n    console.error('Erro ao buscar legenda por URL:', error);\n    return null;\n  }\n};\n\n/**\n * Buscar título de vídeo por URL do vídeo\n * @param {string} videoUrl - URL do vídeo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Título encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .select('*')\n      .eq('video_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .single();\n\n    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned\n      throw error;\n    }\n\n    return data || null;\n  } catch (error) {\n    console.error('Erro ao buscar título por URL:', error);\n    return null;\n  }\n};\n\n/**\n * Migrar dados existentes de imagens para legendas\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor'\n * @returns {Promise<Array>} Legendas migradas\n */\nexport const migrarLegendasExistentes = async (escolaId, tipoFoto = 'escola') => {\n  try {\n    let imagens = [];\n    \n    if (tipoFoto === 'escola') {\n      // Buscar imagens existentes da tabela imagens_escola\n      const { data, error } = await supabase\n        .from('imagens_escola')\n        .select('*')\n        .eq('escola_id', escolaId)\n        .eq('ativo', true);\n\n      if (error) {\n        throw error;\n      }\n      imagens = data || [];\n    } else if (tipoFoto === 'professor') {\n      // Buscar imagens dos professores do bucket\n      const { data, error } = await supabase.storage\n        .from('imagens-professores')\n        .list(`${escolaId}/`);\n\n      if (error) {\n        throw error;\n      }\n      \n      imagens = (data || []).map(file => ({\n        url: `${escolaId}/${file.name}`,\n        descricao: `Imagem do professor - ${file.name}`,\n        created_at: file.created_at\n      }));\n    }\n\n    const legendasMigradas = [];\n\n    for (const imagem of imagens) {\n      // Verificar se já existe legenda para esta imagem\n      const legendaExistente = await getLegendaByImageUrl(imagem.url, escolaId, tipoFoto);\n      \n      if (!legendaExistente) {\n        // Criar nova legenda\n        const novaLegenda = await addLegendaFoto({\n          escola_id: escolaId,\n          imagem_url: imagem.url,\n          legenda: imagem.descricao || `Imagem da ${tipoFoto}`,\n          descricao_detalhada: imagem.descricao,\n          categoria: 'geral',\n          tipo_foto: tipoFoto,\n          ativo: true\n        });\n        \n        legendasMigradas.push(novaLegenda);\n      }\n    }\n\n    return legendasMigradas;\n  } catch (error) {\n    console.error('Erro ao migrar legendas existentes:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes de vídeos para títulos\n * @param {number} escolaId - ID da escola\n * @param {string} videoUrl - URL do vídeo\n * @returns {Promise<Object|null>} Título migrado\n */\nexport const migrarTituloExistente = async (escolaId, videoUrl) => {\n  try {\n    if (!videoUrl) return null;\n\n    // Verificar se já existe título para este vídeo\n    const tituloExistente = await getTituloByVideoUrl(videoUrl, escolaId);\n    \n    if (!tituloExistente) {\n      // Determinar plataforma\n      let plataforma = 'outro';\n      if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {\n        plataforma = 'youtube';\n      } else if (videoUrl.includes('vimeo.com')) {\n        plataforma = 'vimeo';\n      }\n\n      // Criar novo título\n      const novoTitulo = await addTituloVideo({\n        escola_id: escolaId,\n        video_url: videoUrl,\n        titulo: `Vídeo da Escola - ${plataforma.charAt(0).toUpperCase() + plataforma.slice(1)}`,\n        descricao: 'Vídeo relacionado à escola indígena',\n        plataforma: plataforma,\n        categoria: 'geral',\n        ativo: true\n      });\n      \n      return novoTitulo;\n    }\n\n    return tituloExistente;\n  } catch (error) {\n    console.error('Erro ao migrar título existente:', error);\n    throw error;\n  }\n};\n\n/**\n * Função de teste para verificar a estrutura da tabela legendas_fotos\n * @returns {Promise<void>}\n */\nexport const testLegendasTable = async () => {\n  try {\n    console.log('=== TESTE: Verificando estrutura da tabela legendas_fotos ===');\n    \n    // Teste 1: Verificar se a tabela existe\n    const { data: tableData, error: tableError } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .limit(1);\n    \n    console.log('Teste 1 - Tabela existe:', { tableData, tableError });\n    \n    if (tableError) {\n      console.error('❌ ERRO: Tabela legendas_fotos não existe ou não está acessível:', tableError);\n      return;\n    }\n    \n    // Teste 2: Verificar estrutura da tabela\n    const { data: structureData, error: structureError } = await supabase\n      .from('legendas_fotos')\n      .select('id, escola_id, imagem_url, legenda, descricao_detalhada, autor_foto, data_foto, categoria, ativo, created_at, updated_at')\n      .limit(1);\n    \n    console.log('Teste 2 - Estrutura da tabela:', { structureData, structureError });\n    \n    if (structureError) {\n      console.error('❌ ERRO: Problema com estrutura da tabela:', structureError);\n    } else {\n      console.log('✅ Estrutura básica da tabela está OK');\n    }\n    \n    // Teste 3: Verificar se a coluna tipo_foto existe\n    try {\n      const { data: tipoData, error: tipoError } = await supabase\n        .from('legendas_fotos')\n        .select('tipo_foto')\n        .limit(1);\n      \n      console.log('Teste 3 - Coluna tipo_foto:', { tipoData, tipoError });\n      \n      if (tipoError && tipoError.code === '42703') {\n        console.log('⚠️ AVISO: Coluna tipo_foto não existe na tabela');\n      } else if (tipoError) {\n        console.error('❌ ERRO: Problema com coluna tipo_foto:', tipoError);\n      } else {\n        console.log('✅ Coluna tipo_foto existe');\n      }\n    } catch (tipoError) {\n      console.log('⚠️ AVISO: Coluna tipo_foto não existe na tabela');\n    }\n    \n    // Teste 4: Tentar inserir um registro de teste\n    console.log('Teste 4 - Testando inserção...');\n    const testRecord = {\n      escola_id: 999999, // ID que não existe\n      imagem_url: 'test/test.jpg',\n      legenda: 'Teste de legenda',\n      descricao_detalhada: 'Descrição de teste',\n      autor_foto: 'Teste',\n      data_foto: '2024-01-01',\n      categoria: 'teste',\n      ativo: true,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n    \n    try {\n      const { data: insertData, error: insertError } = await supabase\n        .from('legendas_fotos')\n        .insert([testRecord])\n        .select()\n        .single();\n      \n      console.log('Teste 4 - Inserção de teste:', { insertData, insertError });\n      \n      if (insertError) {\n        console.error('❌ ERRO: Problema com inserção:', insertError);\n      } else {\n        console.log('✅ Inserção funcionando - removendo registro de teste...');\n        \n        // Remover o registro de teste\n        const { error: deleteError } = await supabase\n          .from('legendas_fotos')\n          .delete()\n          .eq('id', insertData.id);\n        \n        if (deleteError) {\n          console.error('⚠️ AVISO: Não foi possível remover registro de teste:', deleteError);\n        } else {\n          console.log('✅ Registro de teste removido com sucesso');\n        }\n      }\n    } catch (insertError) {\n      console.error('❌ ERRO: Falha na inserção de teste:', insertError);\n    }\n    \n    console.log('=== FIM DO TESTE ===');\n    \n  } catch (error) {\n    console.error('❌ ERRO GERAL no teste da tabela:', error);\n  }\n}; \n ","import { supabase } from '../supabaseClient';\n\n// Configurações para imagens das histórias do professor\nconst HISTORIA_PROFESSOR_CONFIG = {\n  BUCKET_NAME: 'historia-professor-imagens',\n  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB\n  ALLOWED_TYPES: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'],\n  MAX_IMAGES_PER_HISTORIA: 1,\n  MIN_DIMENSIONS: { width: 200, height: 200 }\n};\n\n/**\n * Valida um arquivo de imagem\n * @param {File} file - Arquivo a ser validado\n * @returns {Object} Resultado da validação\n */\nconst validateImageFile = (file) => {\n  // Verificar tipo MIME\n  if (!HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.includes(file.type)) {\n    return {\n      isValid: false,\n      error: `Tipo de arquivo não suportado. Use apenas: ${HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1].toUpperCase()).join(', ')}`\n    };\n  }\n\n  // Verificar tamanho\n  if (file.size > HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE) {\n    return {\n      isValid: false,\n      error: `Arquivo muito grande. Tamanho máximo: ${HISTORIA_PROFESSOR_CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB`\n    };\n  }\n\n  // Verificar extensão\n  const extension = file.name.split('.').pop().toLowerCase();\n  const allowedExtensions = HISTORIA_PROFESSOR_CONFIG.ALLOWED_TYPES.map(t => t.split('/')[1]);\n  if (!allowedExtensions.includes(extension)) {\n    return {\n      isValid: false,\n      error: `Extensão não permitida. Use apenas: ${allowedExtensions.join(', ')}`\n    };\n  }\n\n  return { isValid: true };\n};\n\n/**\n * Valida dimensões da imagem (opcional)\n * @param {File} file - Arquivo de imagem\n * @returns {Promise<boolean>} Se as dimensões são válidas\n */\nconst validateImageDimensions = (file) => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      const isValid = img.width >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.width &&\n                     img.height >= HISTORIA_PROFESSOR_CONFIG.MIN_DIMENSIONS.height;\n      resolve(isValid);\n    };\n    img.onerror = () => resolve(false);\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n/**\n * Gera nome único para o arquivo\n * @param {File} file - Arquivo\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da história\n * @returns {string} Nome único do arquivo\n */\nconst generateUniqueFileName = (file, escolaId, historiaId) => {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  const extension = file.name.split('.').pop().toLowerCase();\n  return `historia_${historiaId}_${timestamp}_${random}.${extension}`;\n};\n\n/**\n * Buscar todas as histórias do professor de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de histórias\n */\nexport const getHistoriasProfessor = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Adicionar URLs públicas das imagens\n    const historiasComImagens = data.map((historia) => {\n      if (historia.imagem_url) {\n        try {\n          const { data: { publicUrl } } = supabase.storage\n            .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n            .getPublicUrl(historia.imagem_url);\n\n          return { ...historia, imagem_public_url: publicUrl };\n        } catch (err) {\n          return { ...historia, imagem_public_url: null, urlError: err.message };\n        }\n      }\n      return historia;\n    });\n\n    return historiasComImagens;\n\n  } catch (error) {\n    console.error('Erro ao buscar histórias do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Criar nova história do professor\n * @param {Object} historiaData - Dados da história\n * @returns {Promise<Object>} História criada\n */\nexport const createHistoriaProfessor = async (historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .insert([{\n        escola_id: historiaData.escola_id,\n        nome_professor: historiaData.nome_professor || null,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem || 1,\n        ativo: historiaData.ativo !== false\n      }])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    console.error('Erro ao criar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar história do professor\n * @param {number} historiaId - ID da história\n * @param {Object} historiaData - Dados atualizados\n * @returns {Promise<Object>} História atualizada\n */\nexport const updateHistoriaProfessor = async (historiaId, historiaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('historias_professor')\n      .update({\n        nome_professor: historiaData.nome_professor,\n        historia: historiaData.historia,\n        ordem: historiaData.ordem,\n        ativo: historiaData.ativo,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n\n  } catch (error) {\n    console.error('Erro ao atualizar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar história do professor\n * @param {number} historiaId - ID da história\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessor = async (historiaId) => {\n  try {\n    // Deletar a história\n    const { error: deleteError } = await supabase\n      .from('historias_professor')\n      .delete()\n      .eq('id', historiaId);\n\n    if (deleteError) {\n      throw deleteError;\n    }\n  } catch (error) {\n    console.error('Erro ao deletar história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Upload de imagem para uma história do professor\n * @param {File} file - Arquivo de imagem\n * @param {number} escolaId - ID da escola\n * @param {number} historiaId - ID da história\n * @param {string} descricao - Descrição da imagem\n * @returns {Promise<Object>} Dados da imagem salva\n */\nexport const uploadHistoriaProfessorImage = async (file, escolaId, historiaId, descricao = '') => {\n  try {\n    // Validar arquivo\n    const validation = validateImageFile(file);\n    if (!validation.isValid) {\n      throw new Error(validation.error);\n    }\n\n    // Validar dimensões (opcional)\n    const hasValidDimensions = await validateImageDimensions(file);\n    if (!hasValidDimensions) {\n      console.warn('Imagem com dimensões menores que o recomendado');\n    }\n\n    // Gerar nome único\n    const fileName = generateUniqueFileName(file, escolaId, historiaId);\n    const filePath = `${escolaId}/${fileName}`;\n\n    // Upload ao bucket\n    const { error: uploadError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .upload(filePath, file, {\n        cacheControl: '3600',\n        upsert: false\n      });\n\n    if (uploadError) {\n      throw new Error(`Erro no upload: ${uploadError.message}`);\n    }\n\n    // Obter URL pública\n    const { data: { publicUrl } } = supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .getPublicUrl(filePath);\n\n    // Atualizar a história com a URL da imagem\n    const { data: historia, error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: descricao.trim() || null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId)\n      .select()\n      .single();\n\n    if (updateError) {\n      // Se falhar ao atualizar, deletar o arquivo\n      await supabase.storage\n        .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n        .remove([filePath]);\n      throw new Error(`Erro ao salvar metadados: ${updateError.message}`);\n    }\n\n    return {\n      id: historia.id,\n      descricao_imagem: historia.descricao_imagem\n    };\n\n  } catch (error) {\n    console.error('Erro no upload da imagem da história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar imagem de uma história do professor\n * @param {number} historiaId - ID da história\n * @returns {Promise<void>}\n */\nexport const deleteHistoriaProfessorImage = async (historiaId) => {\n  try {\n    // Buscar a história para obter a URL da imagem\n    const { data: historia, error: fetchError } = await supabase\n      .from('historias_professor')\n      .select('imagem_url')\n      .eq('id', historiaId)\n      .single();\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!historia.imagem_url) {\n      return; // Não há imagem para deletar\n    }\n\n    // Atualizar a história removendo a referência da imagem\n    const { error: updateError } = await supabase\n      .from('historias_professor')\n      .update({\n        descricao_imagem: null,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', historiaId);\n\n    if (updateError) {\n      throw updateError;\n    }\n\n    // Deletar arquivo do storage\n    const { error: storageError } = await supabase.storage\n      .from(HISTORIA_PROFESSOR_CONFIG.BUCKET_NAME)\n      .remove([historia.imagem_url]);\n\n    if (storageError) {\n      console.warn('Erro ao deletar imagem do storage:', storageError);\n    }\n\n  } catch (error) {\n    console.error('Erro ao deletar imagem da história do professor:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes da tabela escolas_completa\n * @returns {Promise<Object>} Resultado da migração\n */\nexport const migrarDadosExistentes = async () => {\n  try {\n    // Buscar escolas com história do professor\n    const { data: escolas, error: fetchError } = await supabase\n      .from('escolas_completa')\n      .select('id, historia_do_prof')\n      .not('historia_do_prof', 'is', null)\n      .neq('historia_do_prof', '');\n\n    if (fetchError) {\n      throw fetchError;\n    }\n\n    if (!escolas || escolas.length === 0) {\n      return { migradas: 0, mensagem: 'Nenhuma história para migrar' };\n    }\n\n    // Inserir histórias na nova tabela\n    const historiasParaInserir = escolas.map(escola => ({\n      escola_id: escola.id,\n      historia: escola.historia_do_prof,\n      ordem: 1,\n      ativo: true,\n      created_at: new Date().toISOString()\n    }));\n\n    const { data: historiasInseridas, error: insertError } = await supabase\n      .from('historias_professor')\n      .insert(historiasParaInserir)\n      .select();\n\n    if (insertError) {\n      throw insertError;\n    }\n\n    return {\n      migradas: historiasInseridas.length,\n      mensagem: `${historiasInseridas.length} histórias migradas com sucesso`\n    };\n\n  } catch (error) {\n    console.error('Erro na migração de dados:', error);\n    throw error;\n  }\n};\n\n/**\n * Verificar se uma escola tem histórias do professor\n * @param {number} escolaId - ID da escola\n * @returns {Promise<boolean>} Se tem histórias\n */\nexport const escolaTemHistoriasProfessor = async (escolaId) => {\n  try {\n    const { count, error } = await supabase\n      .from('historias_professor')\n      .select('*', { count: 'exact', head: true })\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (error) {\n      throw error;\n    }\n\n    return (count || 0) > 0;\n\n  } catch (error) {\n    console.error('Erro ao verificar histórias do professor:', error);\n    return false;\n  }\n}; ","import React, { useRef, useState, useEffect } from 'react';\n\n/**\n * DocumentViewer\n * Componente para exibir uma lista de documentos (PDFs) associados a uma escola.\n * Permite visualização via iframe (Google Drive/Docs) ou download externo, com tratamento de erros e fallback amigável.\n * Props:\n *   - documentos: Array de objetos { id, titulo, autoria, tipo, link_pdf }\n *   - title: string (opcional)\n */\n\n// Utility function to transform Google Drive links\nconst transformarLinkGoogleDrive = (link) => {\n  if (!link || typeof link !== 'string') return null;\n  \n  const match = link.match(/\\/d\\/([a-zA-Z0-9-_]+)/);\n  if (!match) return null;\n  \n  const fileId = match[1];\n  return `https://docs.google.com/gview?url=https://drive.google.com/uc?id=${fileId}&embedded=true`;\n};\n\n/**\n * Componente de troca de visualização (lista/grade) acessível e reutilizável\n */\nconst ViewModeToggle = ({ viewMode, setViewMode }) => (\n  <div className=\"flex items-center gap-2\" role=\"tablist\" aria-label=\"Modos de visualização dos documentos\">\n    <button\n      type=\"button\"\n      role=\"tab\"\n      aria-selected={viewMode === 'list'}\n      aria-label=\"Visualizar em lista\"\n      aria-pressed={viewMode === 'list'}\n      onClick={() => setViewMode('list')}\n      className={`p-2 rounded-lg flex items-center gap-1 transition-colors focus:outline-none focus:ring-2 focus:ring-green-600 ${\n        viewMode === 'list'\n          ? 'bg-green-100 text-green-800 font-semibold'\n          : 'text-gray-600 hover:bg-gray-100'\n      }`}\n      tabIndex={0}\n    >\n      {/* Ícone de lista */}\n      <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6h16M4 12h16M4 18h16\" />\n      </svg>\n      <span className=\"hidden sm:inline\">Lista</span>\n    </button>\n    <button\n      type=\"button\"\n      role=\"tab\"\n      aria-selected={viewMode === 'grid'}\n      aria-label=\"Visualizar em grade\"\n      aria-pressed={viewMode === 'grid'}\n      onClick={() => setViewMode('grid')}\n      className={`p-2 rounded-lg flex items-center gap-1 transition-colors focus:outline-none focus:ring-2 focus:ring-green-600 ${\n        viewMode === 'grid'\n          ? 'bg-green-100 text-green-800 font-semibold'\n          : 'text-gray-600 hover:bg-gray-100'\n      }`}\n      tabIndex={0}\n    >\n      {/* Ícone de grade */}\n      <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z\" />\n      </svg>\n      <span className=\"hidden sm:inline\">Grade</span>\n    </button>\n  </div>\n);\n\nconst DocumentViewer = ({ documentos, title = \"Documentos\" }) => {\n  const [selectedDoc, setSelectedDoc] = useState(null);\n  const [viewMode, setViewMode] = useState('list'); // 'list' ou 'grid'\n  const iframeRef = useRef(null);\n  const [iframeError, setIframeError] = useState(false);\n  const [useGoogleDocsViewer, setUseGoogleDocsViewer] = useState(false);\n\n  // Reset states when selected document changes\n  useEffect(() => {\n    if (selectedDoc) {\n      setIframeError(false);\n      setUseGoogleDocsViewer(false);\n    }\n  }, [selectedDoc]);\n\n  // Set first document as selected if none is selected\n  useEffect(() => {\n    if (!selectedDoc && documentos?.length > 0) {\n      setSelectedDoc(documentos[0]);\n    }\n  }, [documentos, selectedDoc]);\n\n  // Handle iframe events\n  useEffect(() => {\n    const iframe = iframeRef.current;\n    if (!iframe || !selectedDoc) return;\n\n    const handleLoad = () => {\n      setIframeError(false);\n    };\n\n    const handleError = () => {\n      setIframeError(true);\n      setUseGoogleDocsViewer(true);\n    };\n\n    iframe.addEventListener('load', handleLoad);\n    iframe.addEventListener('error', handleError);\n\n    return () => {\n      iframe.removeEventListener('load', handleLoad);\n      iframe.removeEventListener('error', handleError);\n    };\n  }, [selectedDoc]);\n\n  // Early return after all hooks\n  if (!documentos || documentos.length === 0) {\n    return null;\n  }\n\n  const renderDocumentGrid = () => {\n    return (\n      <div className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6\">\n        {documentos.map((doc) => (\n          <div\n            key={doc.id}\n            className={`\n              flex flex-col justify-between h-full max-w-xs mx-auto\n              rounded-2xl transition-all duration-200 cursor-pointer\n              shadow-sm hover:shadow-lg\n              ${selectedDoc?.id === doc.id\n                ? 'bg-green-100 scale-[1.03]'\n                : 'bg-white hover:bg-green-50'\n              }\n            `}\n            onClick={() => {\n              setSelectedDoc(doc);\n            }}\n            tabIndex={0}\n            aria-label={`Selecionar documento: ${doc.titulo}`}\n          >\n            <div className=\"p-5 flex-1 flex flex-col justify-between\">\n              <h4 className=\"font-semibold text-green-800 mb-2 line-clamp-2 text-lg\">{doc.titulo}</h4>\n              {doc.autoria && (\n                <p className=\"text-sm text-gray-600 mb-2 line-clamp-1\">Por: {doc.autoria}</p>\n              )}\n              {doc.tipo && (\n                <span className=\"inline-block px-2 py-1 text-xs font-medium bg-green-200 text-green-800 rounded-full\">\n                  {doc.tipo}\n                </span>\n              )}\n            </div>\n          </div>\n        ))}\n      </div>\n    );\n  };\n\n  const renderDocumentList = () => {\n    return (\n      <div className=\"space-y-2\">\n        {documentos.map((doc) => (\n          <button\n            key={doc.id}\n            onClick={() => {\n              setSelectedDoc(doc);\n            }}\n            className={`w-full text-left p-3 rounded-lg transition-colors duration-200 ${\n              selectedDoc?.id === doc.id\n                ? 'bg-green-100'\n                : 'hover:bg-green-50'\n            }`}\n          >\n            <h4 className=\"font-medium text-green-800\">{doc.titulo}</h4>\n            {doc.autoria && (\n              <p className=\"text-sm text-gray-600\">Por: {doc.autoria}</p>\n            )}\n            {doc.tipo && (\n              <span className=\"inline-block mt-1 px-2 py-1 text-xs font-medium bg-green-200 text-green-800 rounded-full\">\n                {doc.tipo}\n              </span>\n            )}\n          </button>\n        ))}\n      </div>\n    );\n  };\n\n  const renderDocumentViewer = () => {\n    if (!selectedDoc) return null;\n\n    const isGoogleDriveLink = selectedDoc.link_pdf.includes('drive.google.com/file/d/');\n\n    return (\n      <div className=\"rounded-lg overflow-hidden shadow-lg bg-white\">\n        {isGoogleDriveLink ? (\n          <>\n            {!useGoogleDocsViewer ? (\n              <iframe \n                ref={iframeRef}\n                src={selectedDoc.link_pdf.replace('/view?usp=sharing', '/preview')}\n                width=\"100%\" \n                height=\"500px\"\n                allow=\"autoplay\"\n                loading=\"lazy\"\n                title={selectedDoc.titulo}\n                sandbox=\"allow-same-origin allow-scripts allow-popups allow-forms\"\n                className=\"bg-white\"\n              />\n            ) : (\n              <iframe\n                ref={iframeRef}\n                src={transformarLinkGoogleDrive(selectedDoc.link_pdf)}\n                width=\"100%\"\n                height=\"500px\"\n                allow=\"autoplay\"\n                loading=\"lazy\"\n                title={`${selectedDoc.titulo} (Google Docs Viewer)`}\n                sandbox=\"allow-same-origin allow-scripts allow-popups allow-forms\"\n                className=\"bg-white\"\n              />\n            )}\n            {iframeError && (\n              <div className=\"p-6 text-center text-gray-600 bg-green-100\">\n                <p className=\"mb-3 text-lg\">Não foi possível carregar o documento diretamente.</p>\n                <a\n                  href={selectedDoc.link_pdf}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"inline-flex items-center px-4 py-2 text-base font-medium text-white bg-green-700 hover:bg-green-800 rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg\"\n                >\n                  <svg \n                    className=\"w-5 h-5 mr-2\" \n                    fill=\"none\" \n                    stroke=\"currentColor\" \n                    viewBox=\"0 0 24 24\"\n                  >\n                    <path \n                      strokeLinecap=\"round\" \n                      strokeLinejoin=\"round\" \n                      strokeWidth={2} \n                      d=\"M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14\" \n                    />\n                  </svg>\n                  Abrir em nova aba\n                </a>\n              </div>\n            )}\n          </>\n        ) : (\n          <div className=\"flex justify-center p-6\">\n            <a\n              href={selectedDoc.link_pdf}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"inline-flex items-center px-6 py-3 text-base font-medium text-white bg-green-700 hover:bg-green-800 rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg\"\n            >\n              <svg \n                className=\"w-5 h-5 mr-2\" \n                fill=\"none\" \n                stroke=\"currentColor\" \n                viewBox=\"0 0 24 24\"\n              >\n                <path \n                  strokeLinecap=\"round\" \n                  strokeLinejoin=\"round\" \n                  strokeWidth={2} \n                  d=\"M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" \n                />\n              </svg>\n              Ver documento PDF\n            </a>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"mt-8 max-w-4xl mx-auto\">\n      <div className=\"flex items-center justify-between mb-4\">\n        <h3 className=\"text-xl font-semibold text-green-800\">{title}:</h3>\n        {documentos.length > 1 && (\n          <ViewModeToggle viewMode={viewMode} setViewMode={setViewMode} />\n        )}\n      </div>\n      \n      {documentos.length > 1 && (\n        <div className=\"mb-6\">\n          {viewMode === 'grid' ? renderDocumentGrid() : renderDocumentList()}\n        </div>\n      )}\n      \n      {renderDocumentViewer()}\n    </div>\n  );\n};\n\nexport default React.memo(DocumentViewer); "],"names":["addLegendaFoto","async","console","log","legenda","legendaData","_objectSpread","data","testData","error","testError","supabase","from","select","limit","code","warn","tipo_foto","columnError","insert","single","updateLegendaFoto","id","updates","update","eq","getLegendaByImageUrl","imagemUrl","escolaId","tipoFoto","arguments","length","undefined","query","caminhoRelativo","split","slice","join","query2","ilike","concat","data2","error2","getTituloByVideoUrl","videoUrl","testLegendasTable","tableData","tableError","structureData","structureError","tipoData","tipoError","testRecord","escola_id","imagem_url","descricao_detalhada","autor_foto","data_foto","categoria","ativo","created_at","Date","toISOString","updated_at","insertData","insertError","deleteError","delete","HISTORIA_PROFESSOR_CONFIG","BUCKET_NAME","MAX_FILE_SIZE","ALLOWED_TYPES","MAX_IMAGES_PER_HISTORIA","MIN_DIMENSIONS","width","height","getHistoriasProfessor","order","ascending","map","historia","publicUrl","storage","getPublicUrl","imagem_public_url","err","urlError","message","createHistoriaProfessor","historiaData","nome_professor","ordem","updateHistoriaProfessor","historiaId","deleteHistoriaProfessor","uploadHistoriaProfessorImage","file","descricao","validation","includes","type","isValid","t","toUpperCase","size","extension","name","pop","toLowerCase","allowedExtensions","validateImageFile","Error","hasValidDimensions","Promise","resolve","img","Image","onload","onerror","src","URL","createObjectURL","validateImageDimensions","fileName","generateUniqueFileName","timestamp","now","random","Math","toString","substring","filePath","uploadError","upload","cacheControl","upsert","updateError","descricao_imagem","trim","remove","deleteHistoriaProfessorImage","fetchError","storageError","transformarLinkGoogleDrive","link","match","fileId","ViewModeToggle","_ref","viewMode","setViewMode","_jsxs","className","role","children","onClick","tabIndex","_jsx","fill","stroke","viewBox","strokeLinecap","strokeLinejoin","strokeWidth","d","DocumentViewer","_ref2","documentos","title","selectedDoc","setSelectedDoc","useState","iframeRef","useRef","iframeError","setIframeError","useGoogleDocsViewer","setUseGoogleDocsViewer","useEffect","iframe","current","handleLoad","handleError","addEventListener","removeEventListener","doc","titulo","autoria","tipo","renderDocumentViewer","isGoogleDriveLink","link_pdf","_Fragment","ref","allow","loading","sandbox","replace","href","target","rel","React"],"sourceRoot":""}