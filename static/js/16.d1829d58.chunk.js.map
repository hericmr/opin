{"version":3,"file":"static/js/16.d1829d58.chunk.js","mappings":"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","sources":["components/TestLegendas.js","services/legendasService.js"],"sourcesContent":["import React, { useState } from 'react';\nimport { addLegendaFoto, updateLegendaFoto, getLegendaByImageUrl, testLegendasTable } from '../services/legendasService';\n\nconst TestLegendas = () => {\n  const [testResults, setTestResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  const addLog = (message, type = 'info') => {\n    const timestamp = new Date().toLocaleTimeString();\n    setTestResults(prev => [...prev, { timestamp, message, type }]);\n  };\n\n  const runTests = async () => {\n    setLoading(true);\n    setTestResults([]);\n    \n    try {\n      addLog('=== INICIANDO TESTES DE LEGENDAS ===', 'header');\n      \n      // Teste 1: Verificar estrutura da tabela\n      addLog('Teste 1: Verificando estrutura da tabela...');\n      await testLegendasTable();\n      addLog('‚úÖ Teste da estrutura da tabela conclu√≠do');\n      \n      // Teste 2: Tentar criar uma legenda de teste\n      addLog('Teste 2: Criando legenda de teste...');\n      const testLegenda = {\n        escola_id: 1,\n        imagem_url: 'test/test-image.jpg',\n        legenda: 'Legenda de teste',\n        descricao_detalhada: 'Descri√ß√£o detalhada de teste',\n        autor_foto: 'Teste Autor',\n        data_foto: '2024-01-01',\n        categoria: 'teste',\n        ativo: true,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      \n      const novaLegenda = await addLegendaFoto(testLegenda);\n      addLog(`‚úÖ Legenda criada com ID: ${novaLegenda.id}`);\n      \n      // Teste 3: Buscar a legenda criada\n      addLog('Teste 3: Buscando legenda criada...');\n      const legendaEncontrada = await getLegendaByImageUrl('test/test-image.jpg', 1);\n      if (legendaEncontrada) {\n        addLog(`‚úÖ Legenda encontrada: ${legendaEncontrada.legenda}`);\n      } else {\n        addLog('‚ùå Legenda n√£o encontrada', 'error');\n      }\n      \n      // Teste 4: Atualizar a legenda\n      addLog('Teste 4: Atualizando legenda...');\n      const updateData = {\n        legenda: 'Legenda atualizada',\n        updated_at: new Date().toISOString()\n      };\n      \n      const legendaAtualizada = await updateLegendaFoto(novaLegenda.id, updateData);\n      addLog(`‚úÖ Legenda atualizada: ${legendaAtualizada.legenda}`);\n      \n      // Teste 5: Verificar se a atualiza√ß√£o foi salva\n      addLog('Teste 5: Verificando se a atualiza√ß√£o foi salva...');\n      const legendaVerificada = await getLegendaByImageUrl('test/test-image.jpg', 1);\n      if (legendaVerificada && legendaVerificada.legenda === 'Legenda atualizada') {\n        addLog('‚úÖ Atualiza√ß√£o salva corretamente');\n      } else {\n        addLog('‚ùå Atualiza√ß√£o n√£o foi salva corretamente', 'error');\n      }\n      \n      addLog('=== TESTES CONCLU√çDOS COM SUCESSO ===', 'success');\n      \n    } catch (error) {\n      addLog(`‚ùå ERRO NOS TESTES: ${error.message}`, 'error');\n      console.error('Erro nos testes:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const clearLogs = () => {\n    setTestResults([]);\n  };\n\n  return (\n    <div className=\"p-6 bg-white rounded-lg shadow-lg max-w-4xl mx-auto\">\n      <h2 className=\"text-2xl font-bold mb-4\">Teste de Funcionalidade de Legendas</h2>\n      \n      <div className=\"mb-6\">\n        <button\n          onClick={runTests}\n          disabled={loading}\n          className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 mr-4\"\n        >\n          {loading ? 'Executando Testes...' : 'Executar Testes'}\n        </button>\n        \n        <button\n          onClick={clearLogs}\n          className=\"px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700\"\n        >\n          Limpar Logs\n        </button>\n      </div>\n      \n      <div className=\"bg-gray-100 rounded-lg p-4 max-h-96 overflow-y-auto\">\n        <h3 className=\"font-semibold mb-2\">Logs dos Testes:</h3>\n        {testResults.length === 0 ? (\n          <p className=\"text-gray-500\">Nenhum teste executado ainda.</p>\n        ) : (\n          <div className=\"space-y-1\">\n            {testResults.map((result, index) => (\n              <div key={index} className={`text-sm font-mono ${\n                result.type === 'error' ? 'text-red-600' :\n                result.type === 'success' ? 'text-green-600' :\n                result.type === 'header' ? 'text-blue-600 font-bold' :\n                'text-gray-800'\n              }`}>\n                [{result.timestamp}] {result.message}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n      \n      <div className=\"mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg\">\n        <h4 className=\"font-semibold text-yellow-800 mb-2\">Instru√ß√µes:</h4>\n        <ol className=\"text-sm text-yellow-700 space-y-1 list-decimal list-inside\">\n          <li>Clique em \"Executar Testes\" para verificar se a funcionalidade de legendas est√° funcionando</li>\n          <li>Verifique os logs para identificar poss√≠veis problemas</li>\n          <li>Se houver erros, execute o script SQL no Supabase para corrigir a estrutura da tabela</li>\n          <li>Teste novamente ap√≥s corrigir problemas no banco de dados</li>\n        </ol>\n      </div>\n    </div>\n  );\n};\n\nexport default TestLegendas; ","import { supabase } from '../supabaseClient';\n\n/**\n * Servi√ßo para gerenciar legendas de fotos\n */\n\n/**\n * Testar se a tabela legendas_fotos existe e est√° acess√≠vel\n * @returns {Promise<boolean>} True se a tabela existe\n */\nexport const testLegendasTable = async () => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .select('count')\n      .limit(1);\n    \n    if (error) {\n      console.warn('Tabela legendas_fotos n√£o encontrada ou sem permiss√£o:', error.message);\n      return false;\n    }\n    \n    console.log('Tabela legendas_fotos acess√≠vel');\n    return true;\n  } catch (error) {\n    console.warn('Erro ao testar tabela legendas_fotos:', error.message);\n    return false;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (todos os atributos opcionais)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} options - Op√ß√µes de busca (todos opcionais)\n * @param {string} options.categoria - Categoria da imagem\n * @param {string} options.tipo_foto - Tipo da foto\n * @param {boolean} options.ativo - Se deve buscar apenas ativas\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imageUrl, escolaId, options = {}) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId);\n\n    // Aplicar filtros opcionais\n    if (options.ativo !== false) { // Por padr√£o, busca apenas ativas\n      query = query.eq('ativo', true);\n    }\n    \n    if (options.categoria) {\n      query = query.eq('categoria', options.categoria);\n    }\n    \n    if (options.tipo_foto) {\n      query = query.eq('tipo_foto', options.tipo_foto);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      console.warn('Erro ao buscar legenda:', error.message);\n      return null;\n    }\n\n    // Retorna a primeira legenda encontrada (mais recente)\n    return data && data.length > 0 ? data[0] : null;\n  } catch (error) {\n    console.warn('Erro ao buscar legenda:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (busca flex√≠vel com m√∫ltiplas estrat√©gias)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} preferencias - Prefer√™ncias de busca (todos opcionais)\n * @param {string} preferencias.categoria - Categoria preferida\n * @param {string} preferencias.tipo_foto - Tipo de foto preferido\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlFlexivel = async (imageUrl, escolaId, preferencias = {}) => {\n  try {\n    console.log(`üîç Buscando legenda flex√≠vel para: ${imageUrl} (escola: ${escolaId})`);\n    \n    // Estrat√©gia 1: Busca com prefer√™ncias espec√≠ficas\n    if (preferencias.categoria || preferencias.tipo_foto) {\n      console.log('  üìã Tentativa 1: Busca com prefer√™ncias espec√≠ficas');\n      const legenda = await getLegendaByImageUrl(imageUrl, escolaId, preferencias);\n      if (legenda) {\n        console.log('  ‚úÖ Encontrada com prefer√™ncias espec√≠ficas');\n        return legenda;\n      }\n    }\n\n    // Estrat√©gia 2: Busca apenas por URL e escola (sem outros filtros)\n    console.log('  üìã Tentativa 2: Busca apenas por URL e escola');\n    const { data: data2, error: error2 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error2) {\n      console.warn('  ‚ùå Erro na busca por URL e escola:', error2.message);\n    } else if (data2 && data2.length > 0) {\n      console.log('  ‚úÖ Encontrada por URL e escola');\n      return data2[0];\n    }\n\n    // Estrat√©gia 3: Busca incluindo legendas inativas\n    console.log('  üìã Tentativa 3: Busca incluindo legendas inativas');\n    const { data: data3, error: error3 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .order('created_at', { ascending: false });\n\n    if (error3) {\n      console.warn('  ‚ùå Erro na busca incluindo inativas:', error3.message);\n    } else if (data3 && data3.length > 0) {\n      console.log('  ‚úÖ Encontrada incluindo legendas inativas');\n      return data3[0];\n    }\n\n    // Estrat√©gia 4: Busca por nome do arquivo (sem caminho completo)\n    const nomeArquivo = imageUrl.split('/').pop();\n    console.log(`  üìã Tentativa 4: Busca por nome do arquivo: ${nomeArquivo}`);\n    const { data: data4, error: error4 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .ilike('imagem_url', `%${nomeArquivo}`)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error4) {\n      console.warn('  ‚ùå Erro na busca por nome do arquivo:', error4.message);\n    } else if (data4 && data4.length > 0) {\n      console.log('  ‚úÖ Encontrada por nome do arquivo');\n      return data4[0];\n    }\n\n    console.log('  ‚ùå Nenhuma legenda encontrada com todas as estrat√©gias');\n    return null;\n\n  } catch (error) {\n    console.warn('Erro ao buscar legenda flex√≠vel:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (sem filtro de categoria) - MANTIDA PARA COMPATIBILIDADE\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlAnyCategory = async (imageUrl, escolaId) => {\n  return getLegendaByImageUrlFlexivel(imageUrl, escolaId);\n};\n\n/**\n * Adicionar nova legenda de foto\n * @param {Object} legendaData - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legendaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto existente\n * @param {number} legendaId - ID da legenda\n * @param {Object} updateData - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (legendaId, updateData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(updateData)\n      .eq('id', legendaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto\n * @param {number} legendaId - ID da legenda\n * @returns {Promise<boolean>} True se deletado com sucesso\n */\nexport const deleteLegendaFoto = async (legendaId) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .delete()\n      .eq('id', legendaId);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} categoria - Categoria das imagens (opcional)\n * @returns {Promise<Array>} Lista de legendas\n */\nexport const getLegendasByEscola = async (escolaId, categoria = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId);\n\n    if (categoria) {\n      query = query.eq('categoria', categoria);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas da escola:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar t√≠tulo personalizado de v√≠deo por URL\n * @param {string} videoUrl - URL do v√≠deo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} T√≠tulo encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('categoria', 'video')\n      .single();\n\n    if (error) {\n      // Se n√£o encontrar, retorna null (n√£o √© erro)\n      if (error.code === 'PGRST116') {\n        return null;\n      }\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.warn('Erro ao buscar t√≠tulo do v√≠deo:', error.message);\n    return null;\n  }\n};\n\n/**\n * Atualizar ordem de uma imagem\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {number} ordem - Nova ordem\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateImageOrder = async (imageUrl, escolaId, ordem) => {\n  try {\n    // Primeiro, buscar a legenda existente\n    const legenda = await getLegendaByImageUrl(imageUrl, escolaId, { ativo: false });\n    \n    if (legenda) {\n      // Se existe, atualizar\n      const { data, error } = await supabase\n        .from('legendas_fotos')\n        .update({ ordem, updated_at: new Date().toISOString() })\n        .eq('id', legenda.id)\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    } else {\n      // Se n√£o existe, criar uma entrada b√°sica com ordem\n      const { data, error } = await supabase\n        .from('legendas_fotos')\n        .insert([{\n          escola_id: escolaId,\n          imagem_url: imageUrl,\n          ordem,\n          ativo: true,\n          tipo_foto: 'escola',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        }])\n        .select()\n        .single();\n\n      if (error) throw error;\n      return data;\n    }\n  } catch (error) {\n    console.error('Erro ao atualizar ordem da imagem:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar ordem de m√∫ltiplas imagens\n * @param {Array} imageOrders - Array de objetos { imageUrl, ordem }\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Legendas atualizadas\n */\nexport const updateMultipleImageOrders = async (imageOrders, escolaId) => {\n  try {\n    const updates = await Promise.all(\n      imageOrders.map(({ imageUrl, ordem }) => \n        updateImageOrder(imageUrl, escolaId, ordem)\n      )\n    );\n    return updates;\n  } catch (error) {\n    console.error('Erro ao atualizar ordens das imagens:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola ordenadas por ordem\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - Tipo da foto (opcional, default: 'escola')\n * @returns {Promise<Array>} Lista de legendas ordenadas\n */\nexport const getLegendasByEscolaOrdered = async (escolaId, tipoFoto = 'escola') => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('tipo_foto', tipoFoto)\n      .eq('ativo', true)\n      .order('ordem', { ascending: true, nullsFirst: false })\n      .order('created_at', { ascending: true });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas ordenadas da escola:', error);\n    throw error;\n  }\n};\n\nconst LegendasService = {\n  testLegendasTable,\n  getLegendaByImageUrl,\n  getLegendaByImageUrlFlexivel,\n  getLegendaByImageUrlAnyCategory,\n  addLegendaFoto,\n  updateLegendaFoto,\n  deleteLegendaFoto,\n  getLegendasByEscola,\n  getTituloByVideoUrl,\n  updateImageOrder,\n  updateMultipleImageOrders,\n  getLegendasByEscolaOrdered\n};\n\nexport default LegendasService;\n"],"names":["TestLegendas","testResults","setTestResults","useState","loading","setLoading","addLog","message","type","arguments","length","undefined","timestamp","Date","toLocaleTimeString","prev","_jsxs","className","children","_jsx","onClick","async","testLegendasTable","testLegenda","escola_id","imagem_url","legenda","descricao_detalhada","autor_foto","data_foto","categoria","ativo","created_at","toISOString","updated_at","novaLegenda","addLegendaFoto","concat","id","legendaEncontrada","getLegendaByImageUrl","updateData","legendaAtualizada","updateLegendaFoto","legendaVerificada","error","console","disabled","clearLogs","map","result","index","supabase","from","select","limit","warn","log","imageUrl","escolaId","options","query","eq","tipo_foto","data","order","ascending","getLegendaByImageUrlFlexivel","preferencias","data2","error2","data3","error3","nomeArquivo","split","pop","data4","error4","ilike","insert","legendaData","single","legendaId","update","getTituloByVideoUrl","videoUrl","code","updateImageOrder","ordem","updateMultipleImageOrders","imageOrders","Promise","all","_ref"],"sourceRoot":""}