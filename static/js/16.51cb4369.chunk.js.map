{"version":3,"file":"static/js/16.51cb4369.chunk.js","mappings":"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","sources":["components/TestLegendas.js","services/legendasService.js"],"sourcesContent":["import React, { useState } from 'react';\nimport { addLegendaFoto, updateLegendaFoto, getLegendaByImageUrl, testLegendasTable } from '../services/legendasService';\n\nconst TestLegendas = () => {\n  const [testResults, setTestResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  const addLog = (message, type = 'info') => {\n    const timestamp = new Date().toLocaleTimeString();\n    setTestResults(prev => [...prev, { timestamp, message, type }]);\n  };\n\n  const runTests = async () => {\n    setLoading(true);\n    setTestResults([]);\n    \n    try {\n      addLog('=== INICIANDO TESTES DE LEGENDAS ===', 'header');\n      \n      // Teste 1: Verificar estrutura da tabela\n      addLog('Teste 1: Verificando estrutura da tabela...');\n      await testLegendasTable();\n      addLog('✅ Teste da estrutura da tabela concluído');\n      \n      // Teste 2: Tentar criar uma legenda de teste\n      addLog('Teste 2: Criando legenda de teste...');\n      const testLegenda = {\n        escola_id: 1,\n        imagem_url: 'test/test-image.jpg',\n        legenda: 'Legenda de teste',\n        descricao_detalhada: 'Descrição detalhada de teste',\n        autor_foto: 'Teste Autor',\n        data_foto: '2024-01-01',\n        categoria: 'teste',\n        ativo: true,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      \n      const novaLegenda = await addLegendaFoto(testLegenda);\n      addLog(`✅ Legenda criada com ID: ${novaLegenda.id}`);\n      \n      // Teste 3: Buscar a legenda criada\n      addLog('Teste 3: Buscando legenda criada...');\n      const legendaEncontrada = await getLegendaByImageUrl('test/test-image.jpg', 1);\n      if (legendaEncontrada) {\n        addLog(`✅ Legenda encontrada: ${legendaEncontrada.legenda}`);\n      } else {\n        addLog('❌ Legenda não encontrada', 'error');\n      }\n      \n      // Teste 4: Atualizar a legenda\n      addLog('Teste 4: Atualizando legenda...');\n      const updateData = {\n        legenda: 'Legenda atualizada',\n        updated_at: new Date().toISOString()\n      };\n      \n      const legendaAtualizada = await updateLegendaFoto(novaLegenda.id, updateData);\n      addLog(`✅ Legenda atualizada: ${legendaAtualizada.legenda}`);\n      \n      // Teste 5: Verificar se a atualização foi salva\n      addLog('Teste 5: Verificando se a atualização foi salva...');\n      const legendaVerificada = await getLegendaByImageUrl('test/test-image.jpg', 1);\n      if (legendaVerificada && legendaVerificada.legenda === 'Legenda atualizada') {\n        addLog('✅ Atualização salva corretamente');\n      } else {\n        addLog('❌ Atualização não foi salva corretamente', 'error');\n      }\n      \n      addLog('=== TESTES CONCLUÍDOS COM SUCESSO ===', 'success');\n      \n    } catch (error) {\n      addLog(`❌ ERRO NOS TESTES: ${error.message}`, 'error');\n      console.error('Erro nos testes:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const clearLogs = () => {\n    setTestResults([]);\n  };\n\n  return (\n    <div className=\"p-6 bg-white rounded-lg shadow-lg max-w-4xl mx-auto\">\n      <h2 className=\"text-2xl font-bold mb-4\">Teste de Funcionalidade de Legendas</h2>\n      \n      <div className=\"mb-6\">\n        <button\n          onClick={runTests}\n          disabled={loading}\n          className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 mr-4\"\n        >\n          {loading ? 'Executando Testes...' : 'Executar Testes'}\n        </button>\n        \n        <button\n          onClick={clearLogs}\n          className=\"px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700\"\n        >\n          Limpar Logs\n        </button>\n      </div>\n      \n      <div className=\"bg-gray-100 rounded-lg p-4 max-h-96 overflow-y-auto\">\n        <h3 className=\"font-semibold mb-2\">Logs dos Testes:</h3>\n        {testResults.length === 0 ? (\n          <p className=\"text-gray-500\">Nenhum teste executado ainda.</p>\n        ) : (\n          <div className=\"space-y-1\">\n            {testResults.map((result, index) => (\n              <div key={index} className={`text-sm font-mono ${\n                result.type === 'error' ? 'text-red-600' :\n                result.type === 'success' ? 'text-green-600' :\n                result.type === 'header' ? 'text-blue-600 font-bold' :\n                'text-gray-800'\n              }`}>\n                [{result.timestamp}] {result.message}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n      \n      <div className=\"mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg\">\n        <h4 className=\"font-semibold text-yellow-800 mb-2\">Instruções:</h4>\n        <ol className=\"text-sm text-yellow-700 space-y-1 list-decimal list-inside\">\n          <li>Clique em \"Executar Testes\" para verificar se a funcionalidade de legendas está funcionando</li>\n          <li>Verifique os logs para identificar possíveis problemas</li>\n          <li>Se houver erros, execute o script SQL no Supabase para corrigir a estrutura da tabela</li>\n          <li>Teste novamente após corrigir problemas no banco de dados</li>\n        </ol>\n      </div>\n    </div>\n  );\n};\n\nexport default TestLegendas; ","import { supabase } from '../supabaseClient';\n\n/**\n * Serviço para gerenciar legendas de fotos\n */\n\n/**\n * Testar se a tabela legendas_fotos existe e está acessível\n * @returns {Promise<boolean>} True se a tabela existe\n */\nexport const testLegendasTable = async () => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('count')\n      .limit(1);\n    \n    if (error) {\n      console.warn('Tabela legendas_fotos não encontrada ou sem permissão:', error.message);\n      return false;\n    }\n    \n    console.log('Tabela legendas_fotos acessível');\n    return true;\n  } catch (error) {\n    console.warn('Erro ao testar tabela legendas_fotos:', error.message);\n    return false;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (todos os atributos opcionais)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} options - Opções de busca (todos opcionais)\n * @param {string} options.categoria - Categoria da imagem\n * @param {string} options.tipo_foto - Tipo da foto\n * @param {boolean} options.ativo - Se deve buscar apenas ativas\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imageUrl, escolaId, options = {}) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId);\n\n    // Aplicar filtros opcionais\n    if (options.ativo !== false) { // Por padrão, busca apenas ativas\n      query = query.eq('ativo', true);\n    }\n    \n    if (options.categoria) {\n      query = query.eq('categoria', options.categoria);\n    }\n    \n    if (options.tipo_foto) {\n      query = query.eq('tipo_foto', options.tipo_foto);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      console.warn('Erro ao buscar legenda:', error.message);\n      return null;\n    }\n\n    // Retorna a primeira legenda encontrada (mais recente)\n    return data && data.length > 0 ? data[0] : null;\n  } catch (error) {\n    console.warn('Erro ao buscar legenda:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (busca flexível com múltiplas estratégias)\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {Object} preferencias - Preferências de busca (todos opcionais)\n * @param {string} preferencias.categoria - Categoria preferida\n * @param {string} preferencias.tipo_foto - Tipo de foto preferido\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlFlexivel = async (imageUrl, escolaId, preferencias = {}) => {\n  try {\n    console.log(`🔍 Buscando legenda flexível para: ${imageUrl} (escola: ${escolaId})`);\n    \n    // Estratégia 1: Busca com preferências específicas\n    if (preferencias.categoria || preferencias.tipo_foto) {\n      console.log('  📋 Tentativa 1: Busca com preferências específicas');\n      const legenda = await getLegendaByImageUrl(imageUrl, escolaId, preferencias);\n      if (legenda) {\n        console.log('  ✅ Encontrada com preferências específicas');\n        return legenda;\n      }\n    }\n\n    // Estratégia 2: Busca apenas por URL e escola (sem outros filtros)\n    console.log('  📋 Tentativa 2: Busca apenas por URL e escola');\n    const { data: data2, error: error2 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error2) {\n      console.warn('  ❌ Erro na busca por URL e escola:', error2.message);\n    } else if (data2 && data2.length > 0) {\n      console.log('  ✅ Encontrada por URL e escola');\n      return data2[0];\n    }\n\n    // Estratégia 3: Busca incluindo legendas inativas\n    console.log('  📋 Tentativa 3: Busca incluindo legendas inativas');\n    const { data: data3, error: error3 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imageUrl)\n      .eq('escola_id', escolaId)\n      .order('created_at', { ascending: false });\n\n    if (error3) {\n      console.warn('  ❌ Erro na busca incluindo inativas:', error3.message);\n    } else if (data3 && data3.length > 0) {\n      console.log('  ✅ Encontrada incluindo legendas inativas');\n      return data3[0];\n    }\n\n    // Estratégia 4: Busca por nome do arquivo (sem caminho completo)\n    const nomeArquivo = imageUrl.split('/').pop();\n    console.log(`  📋 Tentativa 4: Busca por nome do arquivo: ${nomeArquivo}`);\n    const { data: data4, error: error4 } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .ilike('imagem_url', `%${nomeArquivo}`)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error4) {\n      console.warn('  ❌ Erro na busca por nome do arquivo:', error4.message);\n    } else if (data4 && data4.length > 0) {\n      console.log('  ✅ Encontrada por nome do arquivo');\n      return data4[0];\n    }\n\n    console.log('  ❌ Nenhuma legenda encontrada com todas as estratégias');\n    return null;\n\n  } catch (error) {\n    console.warn('Erro ao buscar legenda flexível:', error.message);\n    return null;\n  }\n};\n\n/**\n * Buscar legenda por URL da imagem (sem filtro de categoria) - MANTIDA PARA COMPATIBILIDADE\n * @param {string} imageUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrlAnyCategory = async (imageUrl, escolaId) => {\n  return getLegendaByImageUrlFlexivel(imageUrl, escolaId);\n};\n\n/**\n * Adicionar nova legenda de foto\n * @param {Object} legendaData - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legendaData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto existente\n * @param {number} legendaId - ID da legenda\n * @param {Object} updateData - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (legendaId, updateData) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(updateData)\n      .eq('id', legendaId)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto\n * @param {number} legendaId - ID da legenda\n * @returns {Promise<boolean>} True se deletado com sucesso\n */\nexport const deleteLegendaFoto = async (legendaId) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .delete()\n      .eq('id', legendaId);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar legenda:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar todas as legendas de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} categoria - Categoria das imagens (opcional)\n * @returns {Promise<Array>} Lista de legendas\n */\nexport const getLegendasByEscola = async (escolaId, categoria = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId);\n\n    if (categoria) {\n      query = query.eq('categoria', categoria);\n    }\n\n    const { data, error } = await query.order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas da escola:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar título personalizado de vídeo por URL\n * @param {string} videoUrl - URL do vídeo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Título encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('categoria', 'video')\n      .single();\n\n    if (error) {\n      // Se não encontrar, retorna null (não é erro)\n      if (error.code === 'PGRST116') {\n        return null;\n      }\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.warn('Erro ao buscar título do vídeo:', error.message);\n    return null;\n  }\n};\n\nexport default {\n  testLegendasTable,\n  getLegendaByImageUrl,\n  getLegendaByImageUrlFlexivel,\n  getLegendaByImageUrlAnyCategory,\n  addLegendaFoto,\n  updateLegendaFoto,\n  deleteLegendaFoto,\n  getLegendasByEscola,\n  getTituloByVideoUrl\n};\n"],"names":["TestLegendas","testResults","setTestResults","useState","loading","setLoading","addLog","message","type","arguments","length","undefined","timestamp","Date","toLocaleTimeString","prev","_jsxs","className","children","_jsx","onClick","async","testLegendasTable","testLegenda","escola_id","imagem_url","legenda","descricao_detalhada","autor_foto","data_foto","categoria","ativo","created_at","toISOString","updated_at","novaLegenda","addLegendaFoto","concat","id","legendaEncontrada","getLegendaByImageUrl","updateData","legendaAtualizada","updateLegendaFoto","legendaVerificada","error","console","disabled","clearLogs","map","result","index","data","supabase","from","select","limit","warn","log","imageUrl","escolaId","options","query","eq","tipo_foto","order","ascending","getLegendaByImageUrlFlexivel","preferencias","data2","error2","data3","error3","nomeArquivo","split","pop","data4","error4","ilike","insert","legendaData","single","legendaId","update","getTituloByVideoUrl","videoUrl","code"],"sourceRoot":""}