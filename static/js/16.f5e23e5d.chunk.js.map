{"version":3,"file":"static/js/16.f5e23e5d.chunk.js","mappings":"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","sources":["components/TestLegendas.js","services/legendasService.js"],"sourcesContent":["import React, { useState } from 'react';\nimport { addLegendaFoto, updateLegendaFoto, getLegendaByImageUrl, testLegendasTable } from '../services/legendasService';\n\nconst TestLegendas = () => {\n  const [testResults, setTestResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  const addLog = (message, type = 'info') => {\n    const timestamp = new Date().toLocaleTimeString();\n    setTestResults(prev => [...prev, { timestamp, message, type }]);\n  };\n\n  const runTests = async () => {\n    setLoading(true);\n    setTestResults([]);\n    \n    try {\n      addLog('=== INICIANDO TESTES DE LEGENDAS ===', 'header');\n      \n      // Teste 1: Verificar estrutura da tabela\n      addLog('Teste 1: Verificando estrutura da tabela...');\n      await testLegendasTable();\n      addLog('✅ Teste da estrutura da tabela concluído');\n      \n      // Teste 2: Tentar criar uma legenda de teste\n      addLog('Teste 2: Criando legenda de teste...');\n      const testLegenda = {\n        escola_id: 1,\n        imagem_url: 'test/test-image.jpg',\n        legenda: 'Legenda de teste',\n        descricao_detalhada: 'Descrição detalhada de teste',\n        autor_foto: 'Teste Autor',\n        data_foto: '2024-01-01',\n        categoria: 'teste',\n        ativo: true,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      \n      const novaLegenda = await addLegendaFoto(testLegenda);\n      addLog(`✅ Legenda criada com ID: ${novaLegenda.id}`);\n      \n      // Teste 3: Buscar a legenda criada\n      addLog('Teste 3: Buscando legenda criada...');\n      const legendaEncontrada = await getLegendaByImageUrl('test/test-image.jpg', 1);\n      if (legendaEncontrada) {\n        addLog(`✅ Legenda encontrada: ${legendaEncontrada.legenda}`);\n      } else {\n        addLog('❌ Legenda não encontrada', 'error');\n      }\n      \n      // Teste 4: Atualizar a legenda\n      addLog('Teste 4: Atualizando legenda...');\n      const updateData = {\n        legenda: 'Legenda atualizada',\n        updated_at: new Date().toISOString()\n      };\n      \n      const legendaAtualizada = await updateLegendaFoto(novaLegenda.id, updateData);\n      addLog(`✅ Legenda atualizada: ${legendaAtualizada.legenda}`);\n      \n      // Teste 5: Verificar se a atualização foi salva\n      addLog('Teste 5: Verificando se a atualização foi salva...');\n      const legendaVerificada = await getLegendaByImageUrl('test/test-image.jpg', 1);\n      if (legendaVerificada && legendaVerificada.legenda === 'Legenda atualizada') {\n        addLog('✅ Atualização salva corretamente');\n      } else {\n        addLog('❌ Atualização não foi salva corretamente', 'error');\n      }\n      \n      addLog('=== TESTES CONCLUÍDOS COM SUCESSO ===', 'success');\n      \n    } catch (error) {\n      addLog(`❌ ERRO NOS TESTES: ${error.message}`, 'error');\n      console.error('Erro nos testes:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const clearLogs = () => {\n    setTestResults([]);\n  };\n\n  return (\n    <div className=\"p-6 bg-white rounded-lg shadow-lg max-w-4xl mx-auto\">\n      <h2 className=\"text-2xl font-bold mb-4\">Teste de Funcionalidade de Legendas</h2>\n      \n      <div className=\"mb-6\">\n        <button\n          onClick={runTests}\n          disabled={loading}\n          className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 mr-4\"\n        >\n          {loading ? 'Executando Testes...' : 'Executar Testes'}\n        </button>\n        \n        <button\n          onClick={clearLogs}\n          className=\"px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700\"\n        >\n          Limpar Logs\n        </button>\n      </div>\n      \n      <div className=\"bg-gray-100 rounded-lg p-4 max-h-96 overflow-y-auto\">\n        <h3 className=\"font-semibold mb-2\">Logs dos Testes:</h3>\n        {testResults.length === 0 ? (\n          <p className=\"text-gray-500\">Nenhum teste executado ainda.</p>\n        ) : (\n          <div className=\"space-y-1\">\n            {testResults.map((result, index) => (\n              <div key={index} className={`text-sm font-mono ${\n                result.type === 'error' ? 'text-red-600' :\n                result.type === 'success' ? 'text-green-600' :\n                result.type === 'header' ? 'text-blue-600 font-bold' :\n                'text-gray-800'\n              }`}>\n                [{result.timestamp}] {result.message}\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n      \n      <div className=\"mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg\">\n        <h4 className=\"font-semibold text-yellow-800 mb-2\">Instruções:</h4>\n        <ol className=\"text-sm text-yellow-700 space-y-1 list-decimal list-inside\">\n          <li>Clique em \"Executar Testes\" para verificar se a funcionalidade de legendas está funcionando</li>\n          <li>Verifique os logs para identificar possíveis problemas</li>\n          <li>Se houver erros, execute o script SQL no Supabase para corrigir a estrutura da tabela</li>\n          <li>Teste novamente após corrigir problemas no banco de dados</li>\n        </ol>\n      </div>\n    </div>\n  );\n};\n\nexport default TestLegendas; ","import { supabase } from '../supabaseClient';\n\n/**\n * Buscar legendas de fotos de uma escola\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor' (opcional, busca todas se não especificado)\n * @returns {Promise<Array>} Lista de legendas de fotos\n */\nexport const getLegendasFotos = async (escolaId, tipoFoto = null) => {\n  try {\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    // Verificar se a coluna tipo_foto existe antes de usá-la\n    if (tipoFoto) {\n      try {\n        query = query.eq('tipo_foto', tipoFoto);\n      } catch (columnError) {\n        // Se a coluna não existe, ignorar o filtro por tipo\n        console.warn('Coluna tipo_foto não encontrada. Ignorando filtro por tipo.');\n      }\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar legendas de fotos:', error);\n    throw error;\n  }\n};\n\n/**\n * Adicionar legenda de foto\n * @param {Object} legenda - Dados da legenda\n * @returns {Promise<Object>} Legenda criada\n */\nexport const addLegendaFoto = async (legenda) => {\n  try {\n    console.log('=== DEBUG: addLegendaFoto ===');\n    console.log('Dados recebidos:', legenda);\n    \n    // Remover tipo_foto se a coluna não existir no banco\n    const legendaData = { ...legenda };\n    console.log('Dados iniciais:', legendaData);\n    \n    // Limpar campos vazios que podem causar problemas com o banco\n    Object.keys(legendaData).forEach(key => {\n      if (legendaData[key] === '' || legendaData[key] === null) {\n        delete legendaData[key];\n      }\n    });\n    \n    // Verificar se a coluna tipo_foto existe antes de incluí-la\n    try {\n      console.log('Verificando se a coluna tipo_foto existe...');\n      // Tentar uma consulta simples para verificar se a coluna existe\n      const { data: testData, error: testError } = await supabase\n        .from('legendas_fotos')\n        .select('tipo_foto')\n        .limit(1);\n      \n      console.log('Teste da coluna tipo_foto:', { testData, testError });\n      \n      if (testError && testError.code === '42703') {\n        // Se a coluna não existe, remover do objeto\n        console.warn('Coluna tipo_foto não encontrada. Removendo do objeto de inserção.');\n        delete legendaData.tipo_foto;\n      }\n    } catch (columnError) {\n      // Se a coluna não existe, remover do objeto\n      console.warn('Coluna tipo_foto não encontrada. Removendo do objeto de inserção.');\n      delete legendaData.tipo_foto;\n    }\n\n    console.log('Dados finais para inserção:', legendaData);\n    \n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .insert([legendaData])\n      .select()\n      .single();\n\n    console.log('Resposta do Supabase:', { data, error });\n\n    if (error) {\n      console.error('Erro do Supabase:', error);\n      throw error;\n    }\n\n    console.log('Legenda criada com sucesso:', data);\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar legenda de foto\n * @param {number} id - ID da legenda\n * @param {Object} updates - Dados para atualizar\n * @returns {Promise<Object>} Legenda atualizada\n */\nexport const updateLegendaFoto = async (id, updates) => {\n  try {\n    console.log('=== DEBUG: updateLegendaFoto ===');\n    console.log('ID da legenda:', id);\n    console.log('Dados para atualização:', updates);\n    \n    // Limpar campos vazios que podem causar problemas com o banco\n    const cleanUpdates = { ...updates };\n    Object.keys(cleanUpdates).forEach(key => {\n      if (cleanUpdates[key] === '' || cleanUpdates[key] === null) {\n        delete cleanUpdates[key];\n      }\n    });\n    \n    console.log('Dados limpos para atualização:', cleanUpdates);\n    \n    const { data, error } = await supabase\n      .from('legendas_fotos')\n      .update(cleanUpdates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    console.log('Resposta do Supabase:', { data, error });\n\n    if (error) {\n      console.error('Erro do Supabase ao atualizar:', error);\n      throw error;\n    }\n\n    console.log('Legenda atualizada com sucesso:', data);\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar legenda de foto (soft delete)\n * @param {number} id - ID da legenda\n * @returns {Promise<boolean>} Sucesso da operação\n */\nexport const deleteLegendaFoto = async (id) => {\n  try {\n    const { error } = await supabase\n      .from('legendas_fotos')\n      .update({ ativo: false })\n      .eq('id', id);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar legenda de foto:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar títulos de vídeos de uma escola\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Array>} Lista de títulos de vídeos\n */\nexport const getTitulosVideos = async (escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .select('*')\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('Erro ao buscar títulos de vídeos:', error);\n    throw error;\n  }\n};\n\n/**\n * Adicionar título de vídeo\n * @param {Object} titulo - Dados do título\n * @returns {Promise<Object>} Título criado\n */\nexport const addTituloVideo = async (titulo) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .insert([titulo])\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao adicionar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Atualizar título de vídeo\n * @param {number} id - ID do título\n * @param {Object} updates - Dados para atualizar\n * @returns {Promise<Object>} Título atualizado\n */\nexport const updateTituloVideo = async (id, updates) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .update(updates)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Erro ao atualizar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Deletar título de vídeo (soft delete)\n * @param {number} id - ID do título\n * @returns {Promise<boolean>} Sucesso da operação\n */\nexport const deleteTituloVideo = async (id) => {\n  try {\n    const { error } = await supabase\n      .from('titulos_videos')\n      .update({ ativo: false })\n      .eq('id', id);\n\n    if (error) {\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Erro ao deletar título de vídeo:', error);\n    throw error;\n  }\n};\n\n/**\n * Buscar legenda de foto por URL da imagem\n * @param {string} imagemUrl - URL da imagem\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor' (opcional)\n * @returns {Promise<Object|null>} Legenda encontrada ou null\n */\nexport const getLegendaByImageUrl = async (imagemUrl, escolaId, tipoFoto = null) => {\n  try {\n    console.log('getLegendaByImageUrl chamada com:', { imagemUrl, escolaId, tipoFoto });\n    \n    // 1. Tenta buscar por igualdade exata\n    let query = supabase\n      .from('legendas_fotos')\n      .select('*')\n      .eq('imagem_url', imagemUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true);\n\n    if (tipoFoto) {\n      try {\n        query = query.eq('tipo_foto', tipoFoto);\n      } catch (columnError) {\n        console.warn('Coluna tipo_foto não encontrada. Ignorando filtro por tipo.');\n      }\n    }\n\n    let { data, error } = await query.single();\n    console.log('Busca exata resultou em:', { data, error });\n\n    // Se não encontrou, tenta buscar por finalização\n    if ((error && error.code === 'PGRST116') || !data) {\n      console.log('Tentando busca por finalização...');\n      // Busca por finalização (ilike)\n      const caminhoRelativo = imagemUrl.split('/').slice(-2).join('/'); // ex: 20/2.png\n      console.log('Caminho relativo extraído:', caminhoRelativo);\n      \n      let query2 = supabase\n        .from('legendas_fotos')\n        .select('*')\n        .ilike('imagem_url', `%/${caminhoRelativo}`)\n        .eq('escola_id', escolaId)\n        .eq('ativo', true);\n\n      if (tipoFoto) {\n        try {\n          query2 = query2.eq('tipo_foto', tipoFoto);\n        } catch (columnError) {\n          // Se a coluna não existe, ignora\n        }\n      }\n\n      const { data: data2, error: error2 } = await query2.single();\n      console.log('Busca por finalização resultou em:', { data2, error2 });\n      \n      if (!error2 && data2) {\n        return data2;\n      }\n    }\n\n    if (error && error.code !== 'PGRST116') {\n      throw error;\n    }\n\n    return data || null;\n  } catch (error) {\n    console.error('Erro ao buscar legenda por URL:', error);\n    return null;\n  }\n};\n\n/**\n * Buscar título de vídeo por URL do vídeo\n * @param {string} videoUrl - URL do vídeo\n * @param {number} escolaId - ID da escola\n * @returns {Promise<Object|null>} Título encontrado ou null\n */\nexport const getTituloByVideoUrl = async (videoUrl, escolaId) => {\n  try {\n    const { data, error } = await supabase\n      .from('titulos_videos')\n      .select('*')\n      .eq('video_url', videoUrl)\n      .eq('escola_id', escolaId)\n      .eq('ativo', true)\n      .single();\n\n    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned\n      throw error;\n    }\n\n    return data || null;\n  } catch (error) {\n    console.error('Erro ao buscar título por URL:', error);\n    return null;\n  }\n};\n\n/**\n * Migrar dados existentes de imagens para legendas\n * @param {number} escolaId - ID da escola\n * @param {string} tipoFoto - 'escola' ou 'professor'\n * @returns {Promise<Array>} Legendas migradas\n */\nexport const migrarLegendasExistentes = async (escolaId, tipoFoto = 'escola') => {\n  try {\n    let imagens = [];\n    \n    if (tipoFoto === 'escola') {\n      // Buscar imagens existentes da tabela imagens_escola\n      const { data, error } = await supabase\n        .from('imagens_escola')\n        .select('*')\n        .eq('escola_id', escolaId)\n        .eq('ativo', true);\n\n      if (error) {\n        throw error;\n      }\n      imagens = data || [];\n    } else if (tipoFoto === 'professor') {\n      // Buscar imagens dos professores do bucket\n      const { data, error } = await supabase.storage\n        .from('imagens-professores')\n        .list(`${escolaId}/`);\n\n      if (error) {\n        throw error;\n      }\n      \n      imagens = (data || []).map(file => ({\n        url: `${escolaId}/${file.name}`,\n        descricao: `Imagem do professor - ${file.name}`,\n        created_at: file.created_at\n      }));\n    }\n\n    const legendasMigradas = [];\n\n    for (const imagem of imagens) {\n      // Verificar se já existe legenda para esta imagem\n      const legendaExistente = await getLegendaByImageUrl(imagem.url, escolaId, tipoFoto);\n      \n      if (!legendaExistente) {\n        // Criar nova legenda\n        const novaLegenda = await addLegendaFoto({\n          escola_id: escolaId,\n          imagem_url: imagem.url,\n          legenda: imagem.descricao || `Imagem da ${tipoFoto}`,\n          descricao_detalhada: imagem.descricao,\n          categoria: 'geral',\n          tipo_foto: tipoFoto,\n          ativo: true\n        });\n        \n        legendasMigradas.push(novaLegenda);\n      }\n    }\n\n    return legendasMigradas;\n  } catch (error) {\n    console.error('Erro ao migrar legendas existentes:', error);\n    throw error;\n  }\n};\n\n/**\n * Migrar dados existentes de vídeos para títulos\n * @param {number} escolaId - ID da escola\n * @param {string} videoUrl - URL do vídeo\n * @returns {Promise<Object|null>} Título migrado\n */\nexport const migrarTituloExistente = async (escolaId, videoUrl) => {\n  try {\n    if (!videoUrl) return null;\n\n    // Verificar se já existe título para este vídeo\n    const tituloExistente = await getTituloByVideoUrl(videoUrl, escolaId);\n    \n    if (!tituloExistente) {\n      // Determinar plataforma\n      let plataforma = 'outro';\n      if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {\n        plataforma = 'youtube';\n      } else if (videoUrl.includes('vimeo.com')) {\n        plataforma = 'vimeo';\n      }\n\n      // Criar novo título\n      const novoTitulo = await addTituloVideo({\n        escola_id: escolaId,\n        video_url: videoUrl,\n        titulo: `Vídeo da Escola - ${plataforma.charAt(0).toUpperCase() + plataforma.slice(1)}`,\n        descricao: 'Vídeo relacionado à escola indígena',\n        plataforma: plataforma,\n        categoria: 'geral',\n        ativo: true\n      });\n      \n      return novoTitulo;\n    }\n\n    return tituloExistente;\n  } catch (error) {\n    console.error('Erro ao migrar título existente:', error);\n    throw error;\n  }\n};\n\n/**\n * Função de teste para verificar a estrutura da tabela legendas_fotos\n * @returns {Promise<void>}\n */\nexport const testLegendasTable = async () => {\n  try {\n    console.log('=== TESTE: Verificando estrutura da tabela legendas_fotos ===');\n    \n    // Teste 1: Verificar se a tabela existe\n    const { data: tableData, error: tableError } = await supabase\n      .from('legendas_fotos')\n      .select('*')\n      .limit(1);\n    \n    console.log('Teste 1 - Tabela existe:', { tableData, tableError });\n    \n    if (tableError) {\n      console.error('❌ ERRO: Tabela legendas_fotos não existe ou não está acessível:', tableError);\n      return;\n    }\n    \n    // Teste 2: Verificar estrutura da tabela\n    const { data: structureData, error: structureError } = await supabase\n      .from('legendas_fotos')\n      .select('id, escola_id, imagem_url, legenda, descricao_detalhada, autor_foto, data_foto, categoria, ativo, created_at, updated_at')\n      .limit(1);\n    \n    console.log('Teste 2 - Estrutura da tabela:', { structureData, structureError });\n    \n    if (structureError) {\n      console.error('❌ ERRO: Problema com estrutura da tabela:', structureError);\n    } else {\n      console.log('✅ Estrutura básica da tabela está OK');\n    }\n    \n    // Teste 3: Verificar se a coluna tipo_foto existe\n    try {\n      const { data: tipoData, error: tipoError } = await supabase\n        .from('legendas_fotos')\n        .select('tipo_foto')\n        .limit(1);\n      \n      console.log('Teste 3 - Coluna tipo_foto:', { tipoData, tipoError });\n      \n      if (tipoError && tipoError.code === '42703') {\n        console.log('⚠️ AVISO: Coluna tipo_foto não existe na tabela');\n      } else if (tipoError) {\n        console.error('❌ ERRO: Problema com coluna tipo_foto:', tipoError);\n      } else {\n        console.log('✅ Coluna tipo_foto existe');\n      }\n    } catch (tipoError) {\n      console.log('⚠️ AVISO: Coluna tipo_foto não existe na tabela');\n    }\n    \n    // Teste 4: Tentar inserir um registro de teste\n    console.log('Teste 4 - Testando inserção...');\n    const testRecord = {\n      escola_id: 999999, // ID que não existe\n      imagem_url: 'test/test.jpg',\n      legenda: 'Teste de legenda',\n      descricao_detalhada: 'Descrição de teste',\n      autor_foto: 'Teste',\n      data_foto: '2024-01-01',\n      categoria: 'teste',\n      ativo: true,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n    \n    try {\n      const { data: insertData, error: insertError } = await supabase\n        .from('legendas_fotos')\n        .insert([testRecord])\n        .select()\n        .single();\n      \n      console.log('Teste 4 - Inserção de teste:', { insertData, insertError });\n      \n      if (insertError) {\n        console.error('❌ ERRO: Problema com inserção:', insertError);\n      } else {\n        console.log('✅ Inserção funcionando - removendo registro de teste...');\n        \n        // Remover o registro de teste\n        const { error: deleteError } = await supabase\n          .from('legendas_fotos')\n          .delete()\n          .eq('id', insertData.id);\n        \n        if (deleteError) {\n          console.error('⚠️ AVISO: Não foi possível remover registro de teste:', deleteError);\n        } else {\n          console.log('✅ Registro de teste removido com sucesso');\n        }\n      }\n    } catch (insertError) {\n      console.error('❌ ERRO: Falha na inserção de teste:', insertError);\n    }\n    \n    console.log('=== FIM DO TESTE ===');\n    \n  } catch (error) {\n    console.error('❌ ERRO GERAL no teste da tabela:', error);\n  }\n}; \n "],"names":["TestLegendas","testResults","setTestResults","useState","loading","setLoading","addLog","message","type","arguments","length","undefined","timestamp","Date","toLocaleTimeString","prev","_jsxs","className","children","_jsx","onClick","async","testLegendasTable","testLegenda","escola_id","imagem_url","legenda","descricao_detalhada","autor_foto","data_foto","categoria","ativo","created_at","toISOString","updated_at","novaLegenda","addLegendaFoto","concat","id","legendaEncontrada","getLegendaByImageUrl","updateData","legendaAtualizada","updateLegendaFoto","legendaVerificada","error","console","disabled","clearLogs","map","result","index","log","legendaData","_objectSpread","Object","keys","forEach","key","data","testData","testError","supabase","from","select","limit","code","warn","tipo_foto","columnError","insert","single","updates","cleanUpdates","update","eq","imagemUrl","escolaId","tipoFoto","query","caminhoRelativo","split","slice","join","query2","ilike","data2","error2","getTituloByVideoUrl","videoUrl","tableData","tableError","structureData","structureError","tipoData","tipoError","testRecord","insertData","insertError","deleteError","delete"],"sourceRoot":""}